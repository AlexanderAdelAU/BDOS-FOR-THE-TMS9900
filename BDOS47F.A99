;
;---------------------------------------------------------
;
;	BDOS FOR THE 9900/99000
;
;	WRITTEN	BY ALEXANDER.CAMERON
;
;	DURING JULY 1983.

;	18 NOV 2019	BDOS IS CONFIGURED TO SHARE CALLING PROGRAMME WORKSPACE AND STACK
;		THAT IS IT DOES NOT DEFINE ITS OWN STACK
;	25 MAY 2024	NEW VERSION 3 TO INCORPORATE IDE HARD DRIVE - FLOPPY I/F WILL BE REMOVED
;	26 AUGUST 2024	NEW VERSION 4 TO ADD MODULE LOAD CAPABILITY TO ALLOW FOR SEGMENTED MEMORY
;	13 JANUARY 2025 NEW VERSION 4.1 TO ADD LONG CALL INTO BDOS.
;       	01 APRIL 2025   4.6 INCORPORATE INDEPENDANT RDSEC/WRSEC and RDDIR/WRDIR ROUTINES
;	05 APRIL 2025   4.7 SUPPORT FOR MULTISEGMENT ARCHITECTURE CONCEPT 4.7
;-----------------------------------------------------------
;
; DEFINE XOP FUNCTIONS
; THESE XOP ARE DEFINED IN THE MONITOR.
; BECAUSE THE XOP WORKSPACES OVERLAP,
; THEN R0 TO R7 ARE SHARED WHEN A CALL FUNCTION OCCURS.
;
;
;
;
;	DEFINE SOME XOP'S DEFINED IN MONITOR
;
	DXOP	FAR_REF,0
	DXOP	RETF,1
	DXOP	PUSHREG,4
	DXOP	POPREG,5
	DXOP	SETSREG,2
	DXOP	CALL,6
	DXOP	RET,7
	DXOP	PUSH,8
	DXOP	POP,9
	DXOP	WHEX,10		;WRITE OUT A 16 BIT HEX VALUE
;	DXOP	RHEX,11		;READ IN A 16 BIT HEX VALUE
;	DXOP	WRITE,12		;WRITE CHAR IN MSB
;	DXOP	READ,13		;READ CHAR IN MSB
;	DXOP	MESG,14		;OUTPUT NULL TERMINATED MESSAGE
	DXOP	DEBUG,15
;
;	REGISTER EQUATES
;

R0	EQU	0
R1	EQU	1
R2	EQU	2
R3	EQU	3
R4	EQU	4
R5	EQU	5
R6	EQU	6
R7	EQU	7
R8	EQU	8
R9	EQU	9
R10	EQU	10
SP	EQU	10
HALT	EQU	10FFH

;
; OPERATING SYSTEM EQUATES
;
MONITOR:	EQU	0F000H

BDOS:	EQU	0D100H
;
	AORG	BDOS
	JMP	LOCAL_BDOS
;
; LONG CALL IS USED TO GET TO BDOS AND THEN LOCAL CALLS ARE USED TO EXECUTE THE REQUEST.
; LOCATION IS BDOS + 2;  \

;
LONG_BDOS:	; MUST FORCE /PSEL HIGH BEFORE CALLING BDOS

	;STST	R0
	;ANDI	R0,0FF7FH		;DISABLE /PSEL = 1
	;LST	R0

	FAR_REF
	CALL	@BDOS
	RETF
;
; BDOS ENTRY POINT;  BDOS IS CALLED VIA A CALL SO THAT
;
LOCAL_BDOS:	SLA	R2,1		;ADJUST FOR JUMP
	CI	R2,2*40		;MAKE SURE IT A LEGAL VALUE
	JH	EXIT	
	MOV	@FUN00(R2),R0
	B	*R0
;
;#define GETPOS   36  /* get number of current sector */
;#define GOCPM    00  /* go to CP/M */
;#define LSTOUT   05  /* list output */
;#define POSEND   35  /* position file to end */
;#define RDRINP   03  /* reader input */


;
;	JUMP TABLE - ENTER WITH VALUE IN R3
;
FUN00	WORD	BDOS0			;WARM BOOT		
FUN01	WORD	CIN			;CONSOLE INPUT
FUN02	WORD	COUT	 		;CONSOLE OUTPUT (OUTPUT LSB OF R3)
FUN03	WORD	EXIT	
FUN04	WORD	EXIT	
FUN05	WORD	EXIT	
FUN06	WORD	DCONIO			;DIRECT CONSOLE IO		
FUN07	WORD	EXIT	 
FUN08	WORD	EXIT	
FUN09	WORD	EXIT	
FUN10	WORD	EXIT	
FUN11	WORD	EXIT	
FUN12	WORD	EXIT	
FUN13	WORD	EXIT
FUN14	WORD	DSKFUN			;SELECT A DISK 
FUN15	WORD	FOPEN	 		;LONG/NEAR-OPEN A FILE
FUN16	WORD	FCLOSE	 		;CLOSE A FILE
FUN17	WORD	SEARCH1	 		;LONG/NEAR LOOK FOR A FILE
FUN18	WORD	SEARCH2			;SEARCH NEXT
FUN19	WORD	ERAFIL	 		;ERASE A FILE
FUN20	WORD	RDSEQ	 		;LONG/NEAR READ SQUENTIAL
FUN21	WORD	WRSEQ	 		;WRITE SQUENTIAL
FUN22	WORD	MAKFIL	 		;MAKE A FILE
FUN23	WORD	RENAME			;RENAME A FILE	
FUN24	WORD	EXIT	
FUN25	WORD	CDFUNC			;RETURN CURRENT DISK
FUN26	WORD	DMAFUN			;LONG/NEAR SET DMA ADDRESS
FUN27	WORD	MLOAD	 		;LOAD MODULES FROM TABLE
FUN28	WORD	EXIT	 		;
FUN29	WORD	EXIT	 		;
FUN30	WORD	EXIT	 		;
FUN31	WORD	EXIT	 		;
FUN32	WORD	EXIT	 		;
FUN33	WORD	RDRND	 		;READ A RANDOM RECORD
FUN34	WORD	WRRND	 		;WRITE A RANDOM RECORD
FUN35	WORD	GETSIZ			;GET FILE SIZE
FUN36	WORD	SETREL			;SET RELATIVE RECORD
FUN37	WORD	EXIT
FUN38	WORD	EXIT
FUN39	WORD	EXIT
FUN40	WORD	EXIT
EXIT	SETO	R1			;ERROR 
	RET

;
; BIOS EQUATES
;
;
;TEMPORARY TESTING ADDRESS TO MIMIC MONITOR BEING AT LOCATION F000
MON_PTR	EQU	086H			;LOW MEMORY POINTER TO MONITOR
;
;	BIOS VECTORS ARRANGED AS N*L WHERE
;
;	N IS THE NTH VECTOR IN THE MONITOR, AND
;	L IS THE NUMBER OF BYTES PER VECTOR
;
;	WHEN CALLING MRDREC, MWRREC ETC IT IS NECESSARY TO CALL USING
;	LBA VALUES, NOT SECTORS.
;
MCONIN	EQU	MONITOR+3*4	;CONSOLE IN
MCONOUT	EQU	MONITOR+4*4	;CONSOLE OUT
MSELDSK	EQU	MONITOR+5*4	;SET CURRENT LOGGED DRIVE
MRECAL	EQU	MONITOR+6*4
MSEEK	EQU	MONITOR+7*4
MRDID	EQU	MONITOR+10*4
MWBOOT	EQU	MONITOR+11*4	;WARM BOOT
;
; NOTE THAT THESE CALLS ARE REASONABLY COMPLEX AND EXECUTE IN ANOTHER WORKSPACE, SO NO CONSIDERATION
; TO PRESERVING CALLING PROCEDURE REGISTERS IS NECESSARY
;
MRDREC	EQU	MONITOR+8*4	;READ A STANDARD RECOR0D
MWRREC	EQU	MONITOR+9*4	;WRITE A STANDARD RECORD
MRDDBR	EQU	MONITOR+14*4	;READ A STANDARD DIRECTORY/BAT RECORD
MWRDBR	EQU	MONITOR+15*4	;WRITE A STANDARD DIRECTORY RECORD

;
;************************************************************************************************************
;
;	FCB EQUATES
;
;	THE FCB CONSISTS OF 36 BYTES OF DATA:
;	ONLY BYTES 0 TO 31 ARE AN EXACT COPY OF THE DIRECTORY ENTRY
;
;	   
;	   BYTES	FUNCTION
;	   -----        --------
;	   0 -7	FILENAME
;	   8 -10 	FILENAME EXTENSION
;	   11	FTY  - FILE TYPE
;	   12-13	FSB  - FILE'S STARTING BLOCK
;	   14-15 	FSZ  - FILE SIZE IN RECORDS (A RECORD IS EQUIVALENT TO A SECTOR)
;	   16-17 	FLA  - FILE LOAD ADDRESS - USED TO DETERMINE WHERE FILE WILL LOAD
;	   18-19	FSZBH - FILE SIZE IN BYTES HIGH WORD
;	   20-21	LRBL - THIS LAST RECORD BYTE LENGTH OR NUMBER OF BYTES IN THE LAST RECORD
;		SO ACTUAL FILE SIZE IN BYTES IS 512*FSZ - (512 - FSZBL)
;	   22-23 	SPARE COULD MAKE THIS DATE
;	   24-25	CBN  - FILE'S CURRENT BLOCK NUMBER
;	   26-27	CRN  - CURRENT RECORD NUMBER - DATA BEGINS AT CRN=1.  CRN=O is the MODULE LOAD TABLE
;	   28-29	RELB - RELATIVE BLOCK NUMBER
;	   30-31 	RELR - RELATIVE RECORD NUMBER FILE WILL LOAD.
;
;	-----------------32 to 36 ARE TRANSIENT VALLUES AND NOT IN THE DIRECTORY------------------
;	   .
;	   32	CMLTI - THIS IS THE CURRENT MODULE LOAD INDEX.  JUST ONE BYTE I.E UP TO 256 MODULES
;	   33	NMSECT - MODULE SIZE IN SECTORS. THIS IS THE NUMBER OF RECORDS IN THE PARTICULAR MODULE;
;		WHICH IN POINTED TO MY CMLTI
;	   34	MEMORY PAGE TO LOAD
;	   34 	DRIVE
;	   35 	LBUFCNT - NUMBER BYTES IN LAST BUFFER.  ALLOWS TO MANAGE BINARY FILES SO CPMEOF IS NOT NEEDED
;
;	THE LBA VALUES SEQUENTIALLY GO FROM 0, 2, 4 ETC BECAUSE WE ARE READING BYTES BACK FROM THE DRIVE
;	RATHER THAN 16 BITS , SO TWO 256 READS (2 LBAs) WILL EQUAL 512 BYTES WHICH IS THE NOMINAL BYTES PER SECTOR
;	DISC STRUCTURE.  EACH SECTOR READ WILL READ IN 2 LBA SECTORS
;	[LBA0][LBA2][LBA4][LBA6][LBA8][LBA10][LBA12][LBA14]<-------FILES BEGIN AT BLOCK 2
;	[BOOT][BAT1][BAT2][BAT3][DIR1][DIR2 ][DIR3 ][DIR4 ][REC1BLK2,REC2BLK2,RECS3BLK2,REC4BLK2][REC1BLCK3...ETC]
;	<-------BLOCK 0--------><--------BLOCK 1----------><-----------BLOCK 2------------------>
;
;	EACH BLOCK IS 4 SECTORS OR or 4 x 512 = 2048 Bytes - we can call see the similarity of blocks to pages
;
;	BLOCK ALLOCATION TABLE [BAT] SECTORS ARE INITIALISED TO 0, THUS AVAILABLE BLOCKS ARE INDICATED BY THE VALUE OF 0000H.
;	WITH THE LAST AVAILABLE BLOCK BEING SET TO -1 IN THE LAST BAT PAGE.
;	ALLOCATED BLOCKS HAVE A NON ZERO BLOCK NUMBER POINTING TO THE NEXT BLOCK IN THE LINK AND THE FINAL BLOCK
;	IN THE LINK INDICATED BY A BLOCK NUMBER VALUE OF FF80H WHICH IS A SIMPLE INVERSION OF THE FIRST 9 BITS
;	WHICH ARE UNUSED.
;
;	FOR EXAMPLE, BAT 1 WOULD LOOK LIKE THIS
;
;	BAT 1
;	BLOCK NUMBER	VALUE	COMMENT
;
;	[ 0	FF80   ]	BOOT SECTOR, PLUS BATs OCCUPY A SINGLE BLOCK (BLOCK 0)
;	[ 1	FF80   ]	DIRECTORY SECTORS OCCUPY A SINGLE BLOCK (BLOCK 1)
;	[ 2	0003   ]	POINTS TO NEXT BLOCK IN LINK.  FILE IS SHELL.SYS (2 BLOCKS IN SIZE)
;	[ 3	FF80   ]	LAST BLOCK IN THE FILE
;	[ 4	0005   ]	POINTS TO NEXT BLOCK IN LINK.  FILE IS BDOS.SYS (2 BLOCKS IN SIZE)
;	[ 5	FF80   ]	LAST BLOCK IN THE LINK
;	[ 6	0007   ]	TEST FILE 3 BLOCKS LONG
;	[ 7	0008   ]	2ND BLOCK
;	[ 8	FF80   ]	LAST BLOCK IN FILE
;	[ 9	0000   ]
;	[ 9	0000   ]
;		ETC
;
;	FOR THIS REASON THE FCB MUST CONTAIN THE FILE STARTING BLOCK (FSB) SO THE START  OF THE LINK
; 	CAN BE FOUND.
;
;	BAT SECTORS ARE ORGANSIED AS FOLLOWS:
;
;	BAT SECTOR 1[BLK0,BLK1,BLK2,BLK3.......BLK255]
;	BAT SECTOR 2[BLK256,BLK257,BLK258,.....BLK511]
;	BAT SECTOR 2[BLK512,BLK513,BLK514..... BLK719,-1]
;
;
;	NOTE:  CPM/BDOS OPERATES AT THE RECORD LEVEL SO THE TASK OF TDOS IS TO BE ABLE TO
;	MAP BETWEEN FILE RECORDS LOCATION WITHIN A BLOCK ON THE DISC TRACK AND SECTOR NUMBER
;
;	BAT SECTORS ARE ORGANSISED AS 3 BAT PAGES/SECTOR
;	[PAGE3][PAGE2][PAGE1][ 0 0 0 0 0 0 0 0].
;	SO THE LSB 8 BITS REPRESENT THE ACTUAL BLOCK NUMBER AND THE NEXT 3 BITS THE BAT PAGE NUMBERS
;	BAT 0 = 000, BAT 1 = 001, BAT 2 = 010 AND BAT 3 = 011.
;
;	SO SHIFTING THE BLOCK NUMBER BY 8  SHIFT COUNT AND APPLYING THE MASK 00FFH YIELDS THE PAGE NUMBER
;	TO WHICH THE BLOCK NUMBER BELONGS.
;
;**********************************************************************************************************************
;
NAM	EQU	0	
FTY	EQU	11		;TYPE 
FLA	EQU	16		;FILES LOAD ADDRESS
CRN	EQU	26	 	;NEXT RECORD TO READ/WRITE 
CBN	EQU	24	 	;CURRENT BLOCK NUMBER
RELB	EQU	28		;RANDOM ACCESS RELATIVE BLOCK NUMBER
RELR	EQU	30		;RELATIVE RECORD NUMBER
FSB	EQU	12		;FILE STARTING BLOCK
FSZ	EQU	14		;FILE SIZE IN SECTORS
LRBL	EQU	20		;NUMBER OF BYTES IN THE LAST RECORD
CMLTI	EQU	32		;CURRENT MLINDEX - 0 REFERS TO MAIN MODULE
NMSECT	EQU	33		;NUMBER OF SECTORS/RECORDS IN THE PARTICULAR MODULE
MPAGE	EQU	34
;
; MEDIA TYPE 00FDH FLOPPY DISC HAS BEEN DEPRECATED
;
;TRKDSK	EQU	80		;TRACKS PER DISK
SECTRK	EQU	18		;SECTORS PER TRACK
BYTSEC	EQU	512		;BYTES PER SECTOR
SECBLK	EQU	4		;SECTOR PER BLOCK THIS MEANS THERE ARE 2 BAT SECTORS
				; 80*18*2/SECBLK = 720 IE 2*512 SECTORS REQUIRED
LBASECT	EQU	1		;NUMBER OF LBAS PER SECTOR (DUE TO 256 BYTE READS)
RSVDSEC	EQU	1		;RESERVED SECTORS FOR BOOT SECTOR
NSIDES	EQU	2		;NUMBER OF SIDES
;SECDSK	EQU	NSIDES*SECTRK*TRKDSK	;SECTORS ON DISK
NBATS	EQU	1		;NO OF BAT ENTRIES ie backup etc
NDSECT	EQU	4		;NO OF DIRECTORY SECTORS PER DISK
FBATSEC 	EQU	RSVDSEC+1		;FIRST BAT SECTOR  OFFSET FROM 0
FDIRRN	EQU	4		;FIRST DIRECTORY RECORD NUMBER ()
DIRTRK	EQU	0		;DIRECTORY STARTS HERE
BATTRK	EQU	0
BATSF	EQU	8		;DETERMINES THE BAT PAGE (SEE EXPLANATION ABOVE)
;BATMSK	EQU	01FFH		;BASED ON BYTSEC/2 ENTRIES PER BAT PAGE - USED IN GETBATP
;BATMSK SHOULD BE 00FF
BATMSK	EQU	0FFH		;BASED ON BYTSEC/2 ENTRIES PER BAT PAGE - USED IN GETBATP
LASTBLK	EQU	0FF80H		;INDICATES LAST BLOCK IN A FILE
BUFSIZ	EQU	BYTSEC		;DISK BUFFER SIZE
;
NAMSIZ	EQU	11		;FILENAME SIZE IN BYTES
NAMEOFF2	EQU	18		;2ND NAME OFFSET INTO FCB
DIRSIZ	EQU	32		;NO. OF BYTES PER ENTRY
RDCMD	EQU	1	 	;READ COMMAND
WRCMD	EQU	2	 	;WRITE COMMAND

MINUS1	EQU	-1		;USED FOR GENERAL ERROR
WILD	BYTE	'?'
ALLONES	BYTE	-1		;;USED FOR GENERAL ERROR
	EVEN
;
DISK	WORD	0		;CURRENTLY SELECTED DISK LS BYTE USED
CAB	WORD	0	 	;CURRENTLY ALLOCATED BLOCK NUMBER
CBP   	WORD	0		;CURRENT BAT LOCATION POINTER
CBO	WORD	0		;CURRENT OFFSET INTO BLOCK
CBSECT	WORD	-1		;CURRENT BAT SECTOR IN MEMORY
DIRENT	WORD	0		;USED IN DIRECTORY SEARCH
WRADDR	WORD	DIRBUFF		;CURRENT DMA ADDRESS
DMAADDR	WORD	0		;CURRENT DMA ADDRESS FOR MONITOR
;TRACK	WORD	0
;SECTOR	WORD	0

; LBA + 0 = SECTOR
; LBA + 1 = CYL LSB
; LBA + 2 = CYL MSB
; LBA + 3 = HEAD   (MSB)
;
;LBA	WORD	0,0		;

CDSECT	WORD	0	 	;CURRENT DIRECTORY SECTOR
CCMD	WORD	0	 	;CURRENT COMMAND
	EVEN
;
; LBA CONSTANTS
;
BOOT_LBA	EQU	0
BAT_LBA         EQU	2
DIR_LBA         EQU	8
FINAL_LBA	EQU	16
BLK2_LBA	EQU	18
;
;LONG DISTANCE COMMANDS
;
LDS:	EQU	0780H	;        Long Distance Source instruction operand.
LDD:	EQU	07C0H	;        Long Distance Destination instruction operand.

;
;******************************
;
;	WARM BOOT INTERCEPT
;
;*******************************
;
BDOS0	RET
	CLR	R0			;CLEAR CHANGE AND WRITE FLAGS IN BM
	CLR	@BATCHG			;ZERO CAUSES A BATTO BE READ IN
	B	@MWBOOT			;CALL MONITOR
;
;*******************************
;
;	CONSOLE OUTPUT
;	CHAR IN R3 LSB 
;
;********************************
;
;
COUT	SWPB	R3			;MOVE CHAR TO UPPER MSB FOR MCONOUT
	MOVB	R3,R2	 		;CHAR IN MSB OF R2
	CALL	@MCONOUT
	RET
;
;********************************
;
;	CONSOLE INPUT INTO LSB OF R1
;	NOTE ALL OTHER SYSTEMS USE MSB
;
;********************************
;
CIN	CALL	@MCONIN		;(R0)			;INPUT CHAR IN R1
	SWPB	R1
	RET				;RETURN CHAR IN MSB OF R1
;
;-----------------------------------
;
;  DIRECT CONSOLE IO - BYPASS ANY CHARACTER
;  CHECKING.
;
;  IF R3 = FF00H THEN INPUT A CHAR
;  IF R3 = IS LESS THAN 00FFH THEN OUTPUT THE CHAR IN MSB
;
;-----------------------------------------------------
;
DCONIO	MOVB	@ALLONES,R0
	CB	R3,R0
	JEQ	CIN
	JMP	COUT
;
;*************************
;
;	SELECT A DISK
;
;*************************
;
DSKFUN	MOV	R3,R2	 		;FOR MONITOR
	MOV	R3,@DISK
	B	@MSELDSK

;
;*************************
;
;	GET CURRENT DISK
;	RETURN IN MSB OF R1
;
;*************************
;
CDFUNC	MOV	@DISK,R1	 		;FOR MONITOR
	RET
;
;========================================================================
;
;	BDOS SET THE DMA ADDRESS
;
;=========================================================================
;
DMAFUN
	MOV	R3,@WRADDR		;COPY FOR WRSEQ
	MOV	R3,@DMAADDR
	RET
;******************************
;
;	MONITOR SET THE DMA ADDRESS IN R2
;
;******************************
;
_SETDMA	MOV	R2,@DMAADDR
	RET

;
;=============================================================================
;
; MLOAD - LOAD MODULES USING THE MODULE LOAD TABLE
;
; NOW LOAD THE PROGRAMME's MODULE LOAD TABLE (MLT) (FIRST SECTOR OF ALL NON SYSTEM FILES).
; PROGRAMMES CAN BE MADE UP MULTIPLE MODULES ACROSS MORE THAN A SINGLE MEMORY SEGMENT.
;
;;;;;	CALL	@GETMLT		;LOAD THE FIRST RECORD WHICH IS THE MLT R1 IS CLEAR
;
;
;===============================================================================:
;
MEMBASE:	EQU	80C0H
MLOAD:	CALL	@GETMLT

	LDS
	MOVB	@MPAGE(R8),R0		;THIS IS MEMORY PAGE
	LDS
	MOVB	@NMSECT(R8),R1		;NUMBER OF RECORDS IN THIS MODULE
	LDS
	MOV	@FLA(R8),R2		;FLA OF ZERO IS DEFAULT. THIS IS THE LOAD ADDRESS FOR THE MODULE

;
; NOW LOAD THE FILE ACCORDING TO THE MODULE TABLE
;
	LI	R3,0D000H		;RETURN FREE MEMORY OR LAST LOAD ADDRESS
	RET
;
;--------------------------------------------------------------------------
;
;	OPEN A FILE (FUNCTION 15)
;
;	R3 -> FCB
;
;	THIS FUNCION TRANSFERS ALL THE FILE'S  DIRECTORY DATA
;	TO THE FCB.  IF THE FILE IS NOT FOUND -1 IS RETURNED IN
;	REGISTER R1. NOTE THAT THIS FUNCTION WILL NOT CREATE AN
;	ENTRY IF ONE DOESN'T EXIST. 'MAKEFIL(FUNCTION 22) MUST
;	FIRST BE CALLED, HOWEVER IF 'MAKEFIL' IS CALLED THEN
;	OPEN DOES NOT NEED TO BE CALLED EXPLICITLY IN THIS 
;	INSTANCE.
;
;
;----------------------------------------------------------------------------
;
FOPEN:	MOV	R3,R8		;COPY FCB POINTER FOR INTERNAL USE
	CALL	@SEARCH1		;OPEN THE DIRECTORY - GET POINTER IN R3
	MOV	R1,R1		;SUCCESSFUL OPEN ?
	JLT	OPENE
	MOV	R8,R1
	MOV	R3,R2		;DONT TOUCH DIRECTORY POINTER
	AI	R1,NAMSIZ 		;POINT TO FDE
	AI	R2,NAMSIZ		;R2 -> DIRECTORY ENTRY
	LI	R0,DIRSIZ-NAMSIZ	;NO OF BYTES TO TRANSFER

OPENA:	LDD
	MOVB	*R2+,*R1+		;TRANSFER ENTRIES
	DEC	R0
	JNE	OPENA
;
;  'MAKFIL' ENTERS HERE ALSO;
;

OPENENT:	CLR	R1
 	LDD
 	MOV	R1,@CBN(R8)		;ZERO CURRENT BLOCK FIELD
 	LDD
	MOV	R1,@RELR(R8)
	LDD
	MOV	R1,@RELB(R8)
	LDD
	MOV	R1,@LRBL(R8)
	LDD
	MOV	R1,@CRN(R8)
;	SETO	@MLBUF		;INVALIDATE MLBUF SO IT IS NOT REUSED FROM A PREVIOUS OPEN
	RET

OPENE:	SETO	R1
	RET

;
;  ENTER WITH FCB POINTER IN R3
;
;COPYFCB:	LI	R8,FCB		;LOCAL COPY OF FCB

;=================================================================================
;
;FOR VERSION 4, WE LOAD THE FIRST 512 BYTES INTO MLBUF TO MANAGE THE
;LOCATION TABLE.   THE LOCATION TABLE IS 128 * 4 BYTES LONG OR 512
;THEREFORE THE SECOND SECTOR IS THE FIRST FILE SECTOR.  THE FILE SYSTEM
;DOES NOT NEED TO KNOW ABOUT THIS AS IT JUST MEANS THAT EACH FILE IS 512 BYTES LONGER
;
;ALL FILES, EXCEPT THE SYSTEM FILES HAVE THIS FORMAT.  IT MEANS THAT WHEN A FILE IS CREATED
;AN EMPTY MODULE LOCATION TABLE SECTOR WILL BE ZEROED AND WILL BE THE FIRST SECTOR
;WHICH MEANS THAT IF IT IS ZERO IT IS TREATED AS A NORMAL TPA/LADDR FILE LOAD/SEQUENTIAL READ.
;
;
;CMLTI      NUMBER OF SECTORS   LOAD ADDRESS
;[ 8 bits | ( NMSECT 8 bits)][     16 bits       ]
;[SEG     |   Nx512 sectors ][LOAD ADDRESS OFFSET]
;  0	   12	0X500H
;  1	...etc
;  FF	FF	FFFF	; END OF TABLE
;
;SO BEGIN LOADING AT THE FIRST INDEX.
;THE NEXT INDEX WILL BE USED ONCE THE CRN - NMSECT
;=================================================================================
;
;
; LOAD AND INITIALISE THE LOCATION TABLE INTO MBUF.
; ASSUME R8 HOLDS FCB
;
; CMLTI - THIS IS THE CURRENT MODULE LOAD INDEX.  JUST ONE BYTE I.E UP TO 256 MODULES
; MODS - MODULE SIZE.  THIS IS THE NUMBER OF 512 BYTE RECORDS IN THE PARTICULAR MODULE;
;
; WHICH IN POINTED TO MY CMLTI
;
;
GETMLT:	CLR	R0

	LDD
	MOVB	R0,@CMLTI(R8)		;SET CLMTI TO ZERO
	LI	R3,MLBUF
	MOV	R3,@DMAADDR		;SET DMA ADDRESS FOR MLBUF
	MOV	R8,R3		;NEED THE FCB IN R3
	CALL	@RDSEQ		;RDSEQ INCREMENTS CRN
;
; NOTE:  IF THE MLI IS ZERO, THAT IS, DEFAULT, THEN SETTING THE PARAMETERS BELOW WILL HAVE NO IMPACT
;
	LI	R1,MLBUF		;POINT TO THE MODULE INDEX BUFFER

        LDD
	MOVB	*R1+,@MPAGE(R8)		;THIS IS MEMORY PAGE
        LDD
	MOVB	*R1+,@NMSECT(R8)	;NUMBER OF RECORDS IN THIS MODULE
        LDD
	MOV	*R1,@FLA(R8)		;FLA OF ZERO IS DEFAULT. THIS IS THE LOAD ADDRESS FOR THE MODULE
	CLR	R1
	RET
;
; WE NEED TO ZERO IT AS THIS IS THE DEFAULT FOR A SINGLE MODULE
;
MAKEMLT:	CLR	R0

        LDD
	MOVB	R0,@CMLTI(R8)		;SET CLMTI TO ZERO
	AI	R0, BYTSEC
	LI	R1,MLBUF
MMLTA	CLR	*R1+		;PAGE = 0, NUMBER OF SECTORS = 0, STARTING ADDRESS = 0
	DEC	R0
	JNE	MMLTA
;
	LI	R0,MLBUF
	MOV	R0,@DMAADDR		;SET DMA ADDRESS FOR MLBUF
	MOV	R8,R3		;NEED THE FCB IN R3
	CALL	@WRSEQ		;RDSEQ INCREMENTS CRN ETC
	RET
;
;
;***************************************************************************
;
;	CLOSE A	FILE (FUNCTION 16)
;
;	R3 -> FCB
;
;	SIMILAR TO OPEN FUNCTION EXCEPT THAT THE FILE SHOULD 
;	HAVE BEEN PREVIOUSLY EITHER OPENED USING 'OPEN' OR
;	CREATED USING 'MAKFIL'. ANY OTHER METHOD OF CALLING
;	WILL TRANSFER JUNK TO THE DIRECTORY - NOT A PLEASANT 
;	THOUGHT.
;
;	CLOSE ALSO ZERO'S THE CRN & CBN WORDS SO THAT OPEN DOES
;	NOT HAVE TO INITIALISE THESE TWO VALUES.
;
;*****************************************************************************
;
FCLOSE:	MOV	R3,R8		;COPY FCB POINTER
	CALL	@SEARCH1 		;MAKE SURE THE FILE EXISTS AND OPEN THE DIRECTORY
	MOV	R1,R1	 	;ERROR ?
	JLT	CLOSEB	 	;YES
	MOV	R8,R1		;FCB POINTER
	MOV	R3,R2		;DONT TOUCH R3 IT POINTS TO DIRECTORY ENTRY
	AI	R1,NAMSIZ		;ENTRY DATA POINTER
	AI	R2,NAMSIZ		;DIR ENTRY POINTER
	LI	R0,DIRSIZ-NAMSIZ

FCLOSE1: 	FAR_REF
FC2	LDS
	MOVB	*R1+,*R2+		;UPDATE DIRECTORY ENTRY
	DEC	R0
	JNE	FC2
;	
; UPDATE DIRECTORY ENTRY
;

	CALL	@WRDIR		;UPDATE THE DIRECTORY ENTRY
	LDS
	MOV	@FSZ(R8),R1		;CAN'T RECLAIM IF FILE IS ZERO SIZE
	JEQ	CLOSEB
	CALL	@RECLAIM		;TRY TO RECLAIM UNUSED BLOCKS
CLOSEB	RET
;
;***************************************************
;
;	WRITE SEQUENTIALLY (FUNCTION 21)
;	CALL TO SETDMA BEFORE CALLING THIS FUNCTION
;	R3 -> FCB
;
;	THIS FUNCTION IS CONTROLLED MAINLY BY 
;	THE CRN (NEXT RECORD TO READ) COUNTER.
;
;	FOR VERSION 4 AND THE INTRODUCTION OF MODULES BDOS NEEDS TO FIRST
;	CREATE THE MODULE LOAD HEADER IF THIS THE FIRST WRITE TO AN OPEN FILE.
;
;
;
;*****************************************************
;
WRSEQ:	;WHEX	R3
	MOV	R3,R8		;SAVE FCB POINTER
	CALL	@CRNTBC	 	;CRN TO RELATIVE BLOCK & REMAINDER
	MOV	R3,@CBO		;SAVE OFFSET
;
;	IF WE COULD TRACE FROM EXISTING POSITION WE COULD SPEED THINGS UP AND STOP THRASHING
;	TRACE1 WILL USE CRN
;
	MOV	R2,R3		;R3 NOW HOLDS RELATIVE BLOCK NUMBER
	CALL	@TRACE
	C	R1,R2		;IF ALLOCATED CONTINUE
	JEQ	WRSEQ0
;
;	AT THIS POINT WE HAVE THE CBP FROM TRACE
;	NXTBLK WILL FIND A BLOCK AND ALLOCATE IT (LINK) 
;	BASED ON CBP
;
	CALL	@NXTBLK	 	;LOCATE A BLOCK AND RETURN IN R7
	MOV	R1,R1		;ANY BLOCKS LEFT ?
	JLT	WRSEQ2		;NO - SHOW ERROR
;
;	IN CASE WE CROSS BAT BOUNDARIES WE NEED TO ALLOCATE LAST BLOCK FIRST
;	AND THEN POSTFIX THE CAB FOUND IN TRACE.  TRACE HAS FILLED THE CBP AND
;	CAB WHICH NEED TO BE UPDATED. R7 IS THE CURRENT BLOCK POINTER AND
;	R6 CONTAINS THE FREE BLOCK NUMBER
;
	LI	R1,LASTBLK		;ALLOCATE THIS BLOCK TO THIS FILE
	MOV	R1,*R7		;NEW END OF LINK IN CURRENT BAT FROM NXTBLK
	MOV	R7,@CBP		;AND KEEP CBP UPDATED
	SETO	@BATCHG		;FORCE AN UPDATE TO THE BAT
;
;	NOW UPDATE PREVIOUS LAST BLOCK TO POINT NOW TO THE NEW LAST BLOCK
;
	PUSH	R6		;PUSH NEW ALLOCATED BLOCK CAB
	MOV	@CAB,R3		;GET PREVIOUS LAST BLOCK RETURNED FROM TRACE
	CALL	@GETBATP		;FIND THE BAT AND GET THE POINTER FROM THE INDEX
	POP	R6
	MOV	R6,*R7		;UPDATE TO NEW END OF LINK
	MOV	R6,@CAB		;UPDATED FROM NXTBLK
	SETO	@BATCHG		;FORCE AN UPDATE TO THE BAT
;	
WRSEQ0	;LI	R0,1
	;WHEX	R0
	MOV	@CAB,R2		;RECOVER DISK BLOCK
	MOV	@CBO,R3		;AND OFFSET
	LI	R0,WRCMD
	MOV	R0,@CCMD		;CURRENT COMMAND

	CALL	@RWREC
	;LI	R0,2
	;WHEX	R0
	MOV	R1,R1		;WAS THERE AN ERROR
	JLT	WRSEQ2		;JUMP IF YES


	LDS
	INC	@FSZ(R8) 		;BUMP THE SECTOR COUNT
	LDS
	INC	@CRN(R8) 		;BUMP CURRENT RECORD
	;LI	R0,3
	;WHEX	R0

WRSEQ1	CLR	R1
WRSEQ2	RET

;
;=====================================================================================
;	READ SEQUENTIALLY
;	R3 -> FCB
;	ASSUME THE CALL TO DMAFUNC HAS BEEN MADE SO WE CAN
;	SAFELY SET THE PAGE INDEX IF NECESSARY USING FCB IN R3
;
;=================================================================================
;
RDSEQ:	MOV	R3,R8		;COPY FCB ADDRESS OF FCB
	LDS
	LDD
	C	@CRN(R8),@FSZ(R8)	;END OF FILE ?
	JHE	RDSEQ1		;YES
	CALL	@CRNTBC		;CONVERT CRN TO A RELATIVE BLOCK NUMBER
	MOV	R3,@CBO		;SAVE OFFSET AND USE BLOCK IN R2 TO
	CALL	@TRACE		;TRACE THROUGH THE LINKED ALLOCATION LIST
	MOV	@CBO,R3		;RECOVER VARIABLES FOR RWREC
	MOV	@CAB,R2
	LI	R0,RDCMD
	MOV	R0,@CCMD		;CURRENT COMMAND
;
; R8 HOLDS FCB
;
	CALL	@RWREC
	LDS
	INC	@CRN(R8)		;BUMP TO NEXT RECORD 
	CLR	R1
	RET
;
RDSEQ1	SETO	R1
	RET
;
;*******************************
;
;	R3 -> FCB
;	READ RANDOM RECORD
;
;********************************
;
RDRND:	LDS

        LDD
        MOV	@RELB(R3),@CBN(R3)	;TRANSER RECORD NUMBER
        LDS
        LDD
    	MOV	@RELR(R3),@CRN(R3)
	CALL	@RDSEQ
	LDS
	DEC	@CRN(R8)		;READ RANDOM CAN'T INCREMENT THE CRN
	RET
;
;*******************************
;
;	WRITE RANDOM RECORD
;	R3 -> FCB
;	(R3)RELR  MUST HOLD THE RECORD TO WRITE TO
;
;*******************************
;
WRRND:	MOV	@RELB(R3),@CBN(R3)	;TRANSEFER RECORD NUMBER
	MOV	@RELR(R3),@CRN(R3)
	JMP	WRSEQ		;NORMAL SEQUENTIAL WRITE
;
;*******************************************************
;
;	COMMON READ WRITE ENTRY
;
;	R8 --> FCB
;	R2 = CURRENT BLOCK NUMBER (ID)
;	R3 = CURRENT BLOCK OFFSET
;
;********************************************************
;
RWREC:	SLA	R2,2		;THERE ARE 4 SECTORS PER BLOCK
	A	R2,R3		;WE NOW HAVE THE BASE LBA
	SLA	R3,1		;BECAUSE WE HAVE TO READ TWO LBA FOR AN EFFECTIVE 512 BYTES
	MOV	@WRADDR,R2		;THIS IS THE LOCAL COPY OF DMA ADDR
	CALL	@_SETDMA		;CAUGHT WITH CALLS THROUGH DMAFUN VALUE IN R4 FOR MONITOR
	MOV	@CCMD,R0		;GET TYPE
	CI	R0,WRCMD		;READ ? 
	JNE	RWREC_R	 	;TRY FOR WRITE
	B	@WRREC	 	;RETURN FROM RDREC
RWREC_R:	B	@RDREC	 	;ASSSUME READ
;
;
;***************************************************************
;
;	SEARCH FIRST( LOOK FOR DIRECTORY ENTRY)
;
;	NORMAL DIRECTORY SEARCH BEGINNING AT THE
;	START OF THE DIRECTORY CONTINUING TILL END.
;
;	E5 => DELETED ENTRY	
;	00 => END OF DIRECTORY	
;	R3 -> FCB	
;
;	RETURN 
;		R1 =  MINUS ONE FOR BAD RESULT 
;		R3 -> CURRENT DIRECTORY ENTRY
;
;***************************************************************
;

SEARCH1:	MOV	R3,R8	;SAVE FCB FOR DIROPN
	SETO	@DIRENT	;SET CURRENT SECTOR DIRECTORY INDEX
	CLR	@CDSECT	;BEGIN SEARCHING AT FIRST SECTOR
	CALL	@DIROPN	;OPEN THE DIRECTORY
	JMP	DLOOK	;RETURN FROM DLOOK
;
;***************************************************************
;
;	SEARCH NEXT (SEARCH2)
;
;	SIMILAR TO CPM - BASICALLY CONTINUES
;	WHERE LAST SEARCH LEFT OFF. THAT IS IT 
;	SIMPLY DOES NOT ALTER THE VALUE OF THE 
;	DIRENT AND CDSECT VARIABLES.
;
;**************************************************************
;
SEARCH2:	MOV	R3,R8
	CALL	@DIROPN		;OPEN THE DIRECTORY
	JMP	DLOOK
;
;-------------------------------------------------
;
;  FUCTION 35 - GET FILE SIZE
;
;   R2 = FUNCTION NUMBER
;   R3 -> FCB
;
;   PURPOSE - MOVE THE ADDRESS OF THE LAST RECORD
;	      TO THE RELATIVE FIELDS
;
;-------------------------------------------------
;
GETSIZ:	MOV	R3,R8		;COPY FCB POINTER FOR INTERNAL USE
	CALL	@SEARCH1		;OPEN THE DIRECTORY
	MOV	R1,R1		;SUCCESSFUL OPEN ?
	JLT	GETSIZ1

	LDS
	LDD
	MOV	@FSZ(R8),@RELR(R8)	;TRANSFER THE FILE SIZE
GETSIZ1:	RET
;
;--------------------------------------------------
;
;	FUCTION 36 - SET RELATIVE RECORD
;	R2 =  FUNCTION NUMBER
;	R3 -> FCB
;
;	PURPOSE - THE RELATIVE RECORD FIELD IS SET TO THE
;	SAME FILE ADDRESS AS THE CURRENT BLOCK AND
;	CURRENT RECORD.
;
;---------------------------------------------------
;
SETREL:	LDS

        LDD
        MOV	@CBN(R3),@RELB(R3)	;TRANSFER RECORD POINTERS
        LDS
        LDD
	MOV	@CRN(R3),@RELR(R3)
	RET
;================[AC] UP TO HERE ===============
;
;*****************************************
;
;	GENERAL DIRECTORY SEARCH SUBROUTINE
;	R8 = PTR TO FCB
;	MUST CHECK FILE ATTRIBUTES FOR FILE TYPE
;
;******************************************
;
DBG_DLOOK1:	TEXT	"DBG_DLOOK1"	;TEMP FOR DEBUG
	WORD	0
	EVEN

DLOOK:	CALL	@DIRBLK	 ;GET NEXT ENTRY PNTR IN R3
	JLT	NONTRY	 ;NOT FOUND
;	DEBUG	@DBG_DLOOK1
;	HALT
	MOV	R3,R2	 ;SAVE PNTR TO DIRECTORY ENTRY
	MOVB	*R2,R0	 ;TEST FOR EOD
	JLT	DLOOK	 ;DELETED ENTRY
	JGT	DLOOK4	 ;VALID
	CLR	R3	 ;SHOW END OF DIRECTORY REACHED
	JMP	NONTRY	
DLOOK4	LI	R0,NAMSIZ 	;NUMBER OF CHARS TO MATCH
	MOV	R8,R5	;SAVE FCB PNTR

NXTLTR	FAR_REF
	LDS
	CB	*R5,@WILD	;? WILL MATCH ALL (LIKE CPM)
	JNE	DLOOK5	;PROCESS NORMALLY
	INC	R5	;ELSE ASSUME MATCH SO BUMP POINTERS
	INC	R2
	JMP	DLOOK6
DLOOK5	LDD
	CB	*R2+,*R5+	;MATCH ?
	JNE	DLOOK	 ;NO SO - KEEP LOOKING
DLOOK6	DEC	R0	
	JNE	NXTLTR	 ;CONTINUE
	CLR	R1	 ;SHOW GOOD RESULT
	JMP	DLOOKEX
NONTRY	SETO	R1	 

DLOOKEX	RET		;SHOW NOT FOUND
;
;********************************	
;
;	CREATE A DIRECTORY ENTRY (FUNCTION 22)
;
;	ENTRY: 	R3 -> FCB
;		R2 = 22
;
;	RETURN:	R1 = 0 EMPTY DIRECTORY FOUND
;		R1 = FF NO EMPTY DIRECTORY AVAILABLE
;
;	THIS FUNCTION SHOULD BE CALLED ONLY WITH THE
;	FILENAME IN THE FIRST 10 BYTES OF THE FCB. 'MAKFIL'
;	MAKES A POINT OF ZEROING ALL BAR THE FILENAME WITH
;	THE DIRECTORY ENTRY BEFORE WRITING IT TO DISK. HENCE
;	YOU MUST CALL CLOSE TO PROPERLY TRANSFER ANY FILE 
;	ATTRIBUTES ETC. ALSO NOTE THAT THE FSB WILL BE RETURNED
;	HOWEVER ALL OTHER FCB ENTRIES WILL BE ZEROED.
;
;
;******************************	
;
;IDE_MODIFICTION_IN PROGRESS
;DB_MAKF1:	TEXT	"MAKFL1"	;TEMP FOR DEBUG
;	WORD	0
;	EVEN

MAKFIL:	MOV	R3,R8			;LOCAL FCB COPY
	CALL	@NXTBLK	 		;FIND A SECTOR FOR FSB AND PLACE IN CAB
	MOV	R1,R1	 		;ERROR ?
	JLT	MAKERR			;LOOKS LIKE DISK FULL

 	MOV	R6,@CAB			;UPDATE BLOCK NUMBER AND
	MOV	R7,@CBP			;POINTER TO THE CURRENT BLOCK

	SETO	@DIRENT			;SIMILAR TO SEARCH1
	CLR	@CDSECT			;MUST SET THESE VARIABLES
	CALL	@DIROPN	 		;OPEN THE DIRECTORY
NTHR	CALL	@DIRBLK	 		;GET ENTRY THROUGH R3
	JLT	MAKERR			;END OF DIRECTORY
	MOVB	*R3,R0	 		;CHECK ENTRY
	JGT	NTHR	 		;VALID ENTRY
;
; ASSUME R3 NOW POINTS TO DIR ENTRY
;
	CLR	R0
	MOV	R8,R5		;R8 HOLDS THE FCB
	AI	R5,FTY		;FLUSH FROM FILE TYPE ENTRY
	LI	R2,DIRSIZ-NAMSIZ	;NUMBER OF BYTES TO ZERO

	FAR_REF
MKFIL2	LDD
	MOVB	R0,*R5+         ;ZERO AFTER FILENAME
	DEC	R2
	JNE	MKFIL2
	LDD
	MOV	@CAB,@FSB(R8)		;TRANSFER FSB
	LI	R1,LASTBLK		;MARK AS FIRST AND LAST BLOCK IN BAT
	MOV	@CBP,R0
	MOV	R1,*R0		;SHOW ITS THE LAST BLOCK AS WELL AS THE FIRST
;
; NOW CREATE THE ZERO LENGTH FILE
;
;	MOV	R3,@DMAADDR
	LI	R2,DIRSIZ		;TRANSFER FILENAME + FSB TO DIRECTORY
	MOV	R8,R5	 	;SAVE FCB VECTOR

	FAR_REF
MKFIL1	LDS
	MOVB	*R5+,*R3+		;TRANSER FCB ENTRY TO DIRECTRY RECORD
	DEC	R2
	JNE	MKFIL1
;
;
; CALL WRDIR TO WRITE OUT THE DISC DIRECTORY ENTRY AND THEN UPDATE THE BAT;
; R8 ->  FCB
;
	CALL	@WRDIR
	CALL	@WRBAT	 	;UPDATE BAT AS DIRECTORY ENTRY IS VALID
	MOV	R1,R1		;IF NO ERROR SIMULATE 'OPEN'
	JLT	MAKERR
	B	@OPENENT
MAKERR	SETO	R1 
	RET

;
;*************************************************
;
;  RENAME A FILE
;
;  R3 -> FCB
;  BYTES 0 - 17  OLD NAME
;  BYTES 18- 27  NEW NAME
;
;*************************************************
;
RENAME:	MOV	R3,R8
	CALL	@SEARCH1		;CHECK TO SEE IF THE FILE EXITS
	MOV	R1,R1
	JLT	RENAM2		;NOT FOUND
	LI	R0,NAMSIZ		;FILENAME SIZE	
	MOV	R3,R2		;R2 -> DIRECTORY ENTRY
	MOV	R8,R1
	AI	R1,NAMEOFF2		;POINT TO 2ND FILE NAME
RENAM1	MOVB	*R1+,*R2+		;COPY NEW FILE NAME OVER OLD ONE
	DEC	R0
	JNE	RENAM1		;JUMP IF NOT DONE
;
; NOW WRITE THE NEW DIRECTORY ENTRY BACK
;
	CALL	@WRDIR		;ALL DIRECTORY POINTERS UNTOUCHED FROM SEARCH1
RENAM2	RET
;
;******************************
;
;	ERASE A	DIRECTORY ENTRY
;
;	R3 -> FCB
;
;	ON RETURN R1 = 0 FOR DIRECTORY ENTRY FOUND
;		     = -1 FOR NO DIRECTORY ENTRY FOUND
;
;*******************************
;
ERAFIL:	FAR_REF
	MOV	R3,R8
	CALL	@SEARCH1 		;LOOK FOR THE FILE ENTRY
	MOV	R1,R1	 	;DID WE FIND IT ?
	JLT	ERAERR	 	;NO
	LI	R1,8000H		;R3->DIR ENTRY
	SOCB	R1,@NAM(R3)		;MAKE DELETED
	LDD
	MOV	@FSB(R3),@FSB(R8)	;NB RECOVER BAT POINTER
	DECT	SP
	MOV	@FSZ(R3),*SP		;IF IT IS ZERO THERE ARE NO ALLOCATED BLOCKS
	CALL	@WRDIR	 	;WRITE FDE BACK TO DISK
	MOV	*SP+,R1		;ZERO ?
	JEQ	ERA03
	LDS
	CLR	@FSZ(R8)		;FORCE RE-ALLOCATION OF USED BLOCK

;
;---NOW RELEASE	ALLOCATED BLOCKS
;
RECLAIM:	FAR_REF
	CLR	R3		;START AT FIRST BAT SECTOR
	CALL	@GETBATP 		;READ IN THE BAT TABLE

	LDS
	MOV	@FSZ(R8),R3		;GET FILE SIZE FOR AND
	CALL	@RECTBC		;CONVERT FILE SIZE TO BLOCKS

	CALL	@TRACE		;TRACE THROUGH TO TO BLOCK NUMBER

	LI	R1,LASTBLK
	MOV	*R7,R3		;RECOVER BAT INDEX
	MOV	R1,*R7		;ASSUME LAST LINK ENTRY

	LDS
	MOV	@FSZ(R8),R0		;ZERO FILE SIZE IE RECLAIM ALL BLOCKS?
	JNE	ERA00		;NO
	CLR	*R7		;YES SO ZERO LAST LINK
ERA00	C	R3,R1		;LAST LINK ?
	JEQ	ERA02		;YES
ERA01	CALL	@GETBATP		;GET INDEX (IN R5) TO NEXT BAT
	MOV	*R7,R3 		;NEXT INDEX VALUE
	CLR	*R7		;ZERO TO SHOW BLOCK IS FREE

	C	R3,R1		;CHECK FOR FINAL LINK (I.E. R1 = FF80H)
	JNE	ERA01		;NOT FINISHED - KEEP GOING
ERA02	CALL	@WRBAT		;UPDATE DISK VERSION OF BAT
ERA03	CLR	R1		;DONE
	RET	
ERAERR	SETO	R1
	RET
;
;*********************************
;
;	READ IN THE DIRECTORY
;
;	ENTER WITH  R8 -> FCB
;
;
;*********************************
DIROPN:	MOV	@CDSECT,R3		;ASSUME CURRENT DIRECTORY SECTPR THIS HAS BEEN SET
	LI	R0,DIR_LBA		;GET FIRST DIRECTORY LBA
	SLA	R3,1		;2 LBAS PER SECTOR
	A	R0,R3		;R3 HOLDS THE LBA
;	LI	R2,DIRBUFF 		;BUFFER TO USE
;	CALL	@_SETDMA	 	;BIOS DMA
;	CALL	@RDREC	 	;READ IN DIRECTORY
	LI	R4,DIRBUFF 		;BUFFER TO USE
	CALL	@MRDDBR	 	;READ IN DIRECTORY
	LI	R3,DIRBUFF		;USE SAME BUFFER 
	RET
;
;
;==============================================================
;	FIND THE NEXT DIRECTORY ENTRY
;	DIRENT IS JUST AN OFFSET INTO THE 
;	DIRECTORY BUFFER. ITS VALUUE DEPENDS ON 
;	THE BLOCK SIZE.
;
;	R3 -> TO FILE DIRECTORY CONTENTS
;===============================================================
;
DIRBLK:	INC	@DIRENT	 	;UP THE LAST ENTRY, INITIALISED TO -1
	MOV	@DIRENT,R3
	SLA	R3,5		;*32 IE 32 BYTES DIRECTORY ENTRY
	AI	R3,DIRBUFF		;POINT TO NEXT ENTRY
	CI	R3,DIRBUFF+BUFSIZ	;HAVE WE REACHED THE END OF THE BUFFER
	JL	DIRB01		;NO
	INC	@CDSECT	 	;NOW - TRY NEXT SECTOR
	MOV	@CDSECT,R3		;R3 HOLDS RECORD OFFSET WITHIN BLOCK
	CI	R3,NDSECT		;NUMBER OF SECTORS ALLOCATED TO DIRECTORY
	JHE	DIRB03		;SHOW END OF DIRECTORY
	CALL	@DIROPN		;READ THE DIRECTORY
;
;
	SETO	@DIRENT		;RESET FOR NEXT TIME
	LI	R3,DIRBUFF		;-->DIRECTORY ENTRY
DIRB01:	CLR	R1		;FLAG SET
DIRB02:	MOV	R1,R1	 	;SET STATUS
	RET
DIRB03:	SETO	R1
	JMP	DIRB02
;
;******************************
;
;	CONVERT CRN TO BLOCK NUMBER (CRNTBC)
;
;	THIS ROUTINE SIMPLY DIVIDES RECORD NUMBER
;	BY BLOCK SIZE TO GIVE A RELATIVE BLOCK NO
;	SO THAT THE BAT MAY BE INDEXED VIA RESULT
;	IN R2.
;
;*******************************
;
CRNTBC:	LDS

	MOV	@CRN(R8),R3 	;NEXT RECORD TO READ
;
;	ENTER HERE IF GENERAL RELATIVE CONVERSION REQUIRED
;	R3 MUST HOLD RECORD NUMBER - NOTE RELATIVE OFFSET WITHIN BLOCK IS FOUND
;	RECORDS BEGIN AT 1
;	BLOCKS BEGIN AT 0
;
RECTBC	CLR	R2	 	;FOR DIVIDE
	LI	R0,SECBLK	 	;SECTORS/BLOCK
	DIV	R0,R2	 	;R2 & R3 HOLD RESULT
RECTBC1	RET
;
;------------------------------------------------------------------------
;
;	BLOCK NO. TO TRK/SECT CONVERSION
;
;	THIS ROUTINE WILL CONVERT A GIVEN BLOCK AND
;	AND RECORD NUMBER WITHIN A FILE TO A PHYSICAL
;	TRACK AND SECTOR. I.E. YOU MAY WISH TO LOCATE
;	THE TRACK/SECTOR OF SAY RECORD 3 WITHIN BLOCK
;	10 ETC.
;
;	THIS ROUTINE IS NORMALLY CALLED AFTER A CALL
;	TO CRNTBC/RECTBC WITHIN RDSEQ ,WRSEQ ETC.
;
;	R1 = BLOCK NO.
;	R3 = RECORD OFFSET WITHIN BLOCK
;
;	RECORDS BEGIN AT 1
;	BLOCKS BEGIN AT 0
;
;	RETURN WITH R2=TRACK,R3=SECTOR
;
;	TRK = INT((BLK*SECBLK + R3)/SECTRK)
;	SECT = REMAINDER(BLK...)+1		
;
;	R2 = TRK, R3 = SECT
;
; NOTE NEEDED TO REMOVE THE MULTIPY AS IT HAS A BUG.  SEE 99105 ERRATA
;------------------------------------------------------------------------
;
;REVISED MULTIPLY TO AVOID 99105 MULTIPLY BUG
;

;BTTSC	LI	R0,SECBLK
;	CLR	R2
;	JEQ	BTTSC2
;BTTSC1	A	R1,R2		;R2=BLK*SECBLK
;	DEC	R0
;	JNE	BTTSC1
;BTTSC2	A	R2,R3		;R3=BLK*SECBLK+R3
;	CLR	R2		;MSB OF QUOTIENT
;	LI	R0,SECTRK		;SECTORS/TRACK
;	DIV	R0,R2	 	;R2=TRK,R3=SECT (R2+R3)/R0
;	INC	R3		;TAKES CARE OF ZERO OFFSET FOR CRN
;BTTSC0	RET
;
;*******************************
;
;	
;	FIND A FREE BLOCK	
;	NXTBLK WILL TRAVERSE THE BAT LOOKING FOR A ZEROED
;	BAT ENTRY.  ONCE FOUND NO CHANGE TO THE BAT WILL BE
;	MADE AND ONLY THE POINTERS TO THE ENTRY WILL BE RETURNED.
;	IT IS THEN UP TO THE CALLING PROGRAMME TO INSERT THE NEW
;	LINKS.
;
;	NOTE: RDBAT WILL PULL IN THE APPROPRIATE BAT SECTOR AS REQUIRED
;
;	R8 -> FCB
;
;	R1 = -1 (ERROR)
;	R1 = 0  (GOOD RESULT)
;	
;
;****************************************************************
;
NXTBLK:	MOV	@CAB,R0			;BEGIN AT LAST BLOCK TO SPEED THINGS UP AND TO STOP THRASHING

NXTBLK2	MOV	R0,R3
	CALL	@GETBATP			;FIND THE BAT AND GET THE POINTER FROM THE INDEX

	MOV	*R7,R1			;POINTER IS IN R7
	JEQ	NXTBLK4			;ANY FREE ? YES
	CI	R1,-1			;LAST AVAILABLE BLOCK ?
	JEQ	NXTBLK3			;YES
	INC	R0			;NEXT BLOCK
	JMP	NXTBLK2			;KEEP LOOKING
;
; R7 -> FREE BLOCK
; R6 =  FREE BLOCK NUMBER
;
NXTBLK4	MOV	R0,R6			;COPY FREE BLOCK NUMBER HERE
	CLR	R1			;SHOW SUCCESS
NXTBLK3	MOV	R1,R1			;RETURN WITH RESULT CONDINTION SET
	RET 
;
;****************************
;
;	READ A RANDOM RECORD
;	R8 -> FCB
;	R3 -> LBA
;
;******************************

RDREC:	MOV	@DMAADDR,R4     ;DMA ADDRESS
	CALL	@MRDREC	 	;READ THE RECORD IN
	MOV	R1,R1	 	;ERROR ?
	JEQ	RDREC1	 	;NO
	SETO	R1	 	;SHOW ERROR
RDREC1	MOV	R1,R1
	RET

	;
;****************************
;
;	READ A DIRECTORY/BAT RECORD
;	R4 -> BUFFER
;	R3 -> LBA
;
;******************************

;RDDBR:	CALL	@MRDDBR	 	;READ THE RECORD IN
;	MOV	R1,R1	 	;ERROR ?
;	JEQ	RDDBR1	 	;NO
;	SETO	R1	 	;SHOW ERROR
;RDDBR1	MOV	R1,R1
;	RET
;
;
;******************************
;
;	WRITE A RANDOM RECORD
;	R8 -> FCB
;	R3 -> LBA
;
;*****************************
;
WRREC:	MOV	@DMAADDR,R4
;	CLR R1
	CALL	@MWRREC
	MOV	R1,R1	
	JEQ	WRREC_X
	SETO	R1

WRREC_X	MOV	R1,R1
	RET
;******************************
;
;	WRITE A DIRECTORY BAT RECORD
;	R4 -> BUFFER ADDRESS
;	R3 -> LBA
;
;*****************************
;
;WRDBR:	CALL	@MWRDBR
;	MOV	R1,R1
;	JEQ	WRDBR_X
;	SETO	R1
;WRDBR_X	MOV	R1,R1
;	RET













;
;*************************************************
;*
;*   TRACE THE FILES LINKED LIST AND FIND THE 
;*   BAT ENTRY CORRESPONDING TO THE FILE'S NTH
;*   BLOCK.
;*   ENTER WITH FILES RELATIVE RECORD IN R2 (SET TO -1 IF LAST LINK REQUIRED)
;*   EXIT  WITH DBN (DISK BLOCK NUMBER ) POINTER IN R7
;*   AND WITH R1=R2 IF MATCH TO R1 AND R1=0FFF8 IF LAST LINK
;*
;*   CALL TRACES WITH FSB/CAB DURING WRSEQ TO SPEED UP TRACE
;*
;**************************************************
;
TRACE:	LDS
	MOV	@FSB(R8),R3		;GET FIRST FILE BLOCK - THIS IS THE START OF THE LINK

	CLR	R1		;COUNTER
TRACE1	CALL	@GETBATP		;GET THE BLOCK POINTER TO REQUESTED BAT ENTRY IN R7
	MOV	*R7,R4		;GET NEXT ALLOCATION LINK
	CI	R4,LASTBLK		;IS IT THE LAST BLOCK ?
	JEQ	TRACE3		;YES
	C	R1,R2		;HAVE WE REACHED THE WANTED BLOCK YET ?
	JEQ	TRACE3		;YES
	INC	R1		;BUMP THE RECORD POINTER
	MOV	R4,R3		;GET THE LINK AND KEEP GOING
	JEQ	TRACE2		;CAN'T IMAGINE WHY ?
	JMP	TRACE1
TRACE2	SETO	R1
	RET
TRACE3	MOV	R7,@CBP		;CURRENT BLOCK POINTER
	MOV	R3,@CAB		;AND CURRENT NUMBER
	RET
;
; GETBATP (GET BAT POINTER) CHECK TO SEE IF THE BAT NUMBER (WHICH WILL
; INDEX INTO THE BAT) PASSED
; IN R3 LIES WITHIN THE RANGE OF THE CURRENT
; BAT WHICH IS IN MEMORY. IF NOT IT WILL READ
; THE APPRORIATE BAT INTO THE BUFFER
; R7 WILL BE RETURNED AS A POINTER TO THE INDEXED ELEMENT
; REGISTERS R0->R5 ARE PRESERVED
;
;
GETBATP: 	PUSHREG	R5
	MOV	R3,R1		;THIS IS THE CAB (CURRENTLY ALLOCATED BLOCK)
	SRL	R1,BATSF		;DETERMINE CURRENT BAT PAGE OR SECTOR BASED ON 256 BLOCKS PER PAGE
	C	R1,@CBSECT		;CURRENT BAT SECTOR IN MEMORY
	JEQ	FBAT0		;IN MEMORY
;R1 HOLDS BAT SECTOR TO BE READ IN
	CALL	@RDBAT		;UPDATE MEMORY VERSION OF BAT

;
;	WE HAVE CROSSED TO ANOTHER BAT PAGE, NEED TO ADJUST
;
FBAT0	POPREG	R5		;NEED TO POP HERE TO GET R3
	MOV	R3,R7
	SLA	R7,1		;TWO BYTES PER ENTRY AND MAKES IT WORD EVEN
	ANDI	R7,BATMSK		;MASK OFF HIGH BITS SO WE JUST HAVE THE BLOCK INDEX INTO THE 256 BAT ENTRY PAGE
	AI	R7,BATBUFF		;R7->INDEXED ELEMENT
	RET			;ALL IS OKAY

;
;	READ IN THE BAT
;	R1 HOLDS CURRENT BAT SECTOR TO READ IN 
;	DON'T CHECK IF ALREADY IN MEMORY AS THE CALLING ROUTINE WILL DO THAT
;	R1=0 FOR 1ST 1 FOR 2ND ETC
;
RDBAT:	MOV	@BATCHG,R0		;IF THERE HAS BEEN A CHANGE FIRST UPDATE
	INC	R0
	JNE	RDBAT1		;NO CHANGE SO PERFORM AS REQUESTED
;
;	WRITE MODIFIED BAT TO DISC
;
RDBAT0	C	R1,@CBSECT		;IF BAT SECTOR IN MEMORY EXIT
	JEQ	RDBAT2
	DECT	SP
	MOV	R1,*SP		;CHANGE SO DON'T READ IF IF NOT NECESSARY

	CALL	@WRBAT		;FORCE UPDATE OF DISK BAT

	MOV	*SP+,R1
RDBAT1	MOV	R1,@CBSECT		;NEW SECTOR
	LI	R3,BAT_LBA
	SLA	R1,1		;2 LBAS PER SECTOR
	A	R1,R3		;THIS IS THE BAT
	LI	R4,BATBUFF 		;USE THIS BUFFER
	CALL	@MRDDBR	 	;READ THE DIRECTORY RECORD IN
	MOV	R1,R1	 	;ERROR ?
	JEQ	RDBAT2	 	;NO
	SETO	R1	 	;SHOW ERROR
RDBAT2	MOV	R1,R1
	RET
;
;	WRITE OUT A BAT SECTOR
;	CBSECT HOLDS BAT SECTOR TO BE WRITTEN TO DISK
;
WRBAT:	MOV	@CBSECT,R2 		;BAT SECTOR; 1 TO 3
	LI	R3,BAT_LBA
	SLA	R2,1		;2 LBAS PER SECTOR
	A	R2,R3
	LI	R4,BATBUFF		;USE SAME BUFFER
	CALL	@MWRDBR
	MOV	R1,R1
	JEQ	WRB_X
	SETO	R1
WRB_X	MOV	R1,R1
	CLR	@BATCHG		;DISK BM NOW EQUALS MEMORY VERSION
	RET

;
;
;  WRITE OUT THE DIRECTORY TO THE DISC.
;  R8 HOLDS THE FCB
;
;DB_WRDIR:	TEXT	"WRDIR"	;TEMP FOR DEBUG
;	WORD	0
;	EVEN
WRDIR:	MOV	@CDSECT,R3		;R3 HOLDS RECORD OFFSET WITHIN BLOCK
	SLA	R3,1		;TWO LBAS PER SECTOR
	LI	R0,DIR_LBA		;FIRST DIRECTORY ENTRY LBA VALUE
	A	R0,R3
	LI	R4,DIRBUFF
;
; CALL TO MWRREC
; R3 HOLDS THE LSB OF THE LBA VALUE FOR THE SECTOR WE WANT TO READ OR WRITE
; R4 HOLDS THE BUFFER ADDRESS
;
	CALL	@MWRDBR
	MOV	R1,R1
	JEQ	WRD_X
	SETO	R1

WRD_X	MOV	R1,R1
	RET

;
;======================================================
;	MAP THE TRACK NUMBER IN R2 TO
;	EITHER SIDE 0 OR SIDE 1
;
;	RETURN IN R2 AND @TRACK
;========================================================
;
;SETTRK:	CI	R2,TRKDSK		;CHECK FOR SIDE 2
;	JLT	SETTRK1
;	AI	R2,-2*TRKDSK
;	INC	R2
;	NEG	R2
;	ORI	R2,8000H		;SET MSB TO INDICATE SIDE 1
;SETTRK1:
;	MOV	R2,@TRACK
;	RET
;
;
;	BUFFERS ETC
;
;	THE FLAG BATCHG(BIT MAP CHANGE) IS SET WHENEVER AN ALLOCATION
;	BIT IN THE BLOCK ALLOCATION TABLE (BAT)HAS BEEN 
;	CLEARED/ALLOCATED. THIS ENSURES THAT THE BAT
;	WILL NOT BE OVERWRITTEN BY THE DISK VERSION OF THE BIT MAP.
;	THIS FLAG IS CLEARED ONCE A BIT MAP DISK WRITE IS FORCED BY
;	A FILE CLOSURE OR A DIRECTORY FSB BEING REQUESTED.
;
BATCHG:	WORD	0		;BAT CHANGE FLAG
MCNT:	WORD	0		;BYTES LEFT IN BUFFER





BATBUFF:	BSS	BUFSIZ		;BAT BUFFER
DIRBUFF:	BSS	BUFSIZ		;DIRECTORY BUFFER
INTBUFF:
MLBUF:	BSS	2		;BUFFER FOR C COMPILED PROGRAMMES
;
	END

