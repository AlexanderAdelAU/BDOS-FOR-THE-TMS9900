;
;---------------------------------------------------------
;
;	BDOS FOR THE 9900	
;
;	WRITTEN	BY A.CAMERON 
;
;	DURING JULY 1983.

;	2019	BDOS IS CONFIGURED TO SHARE CALLING PROGRAMME WORKSPACE AND STACK
;		THAT IS ID DOES NOT DEFINE ITS OWN STACK
;
;
;-----------------------------------------------------------
;
; DEFINE XOP FUNCTIONS
; THESE XOP ARE DEFINED IN THE MONITOR.
; BECAUSE THE XOP WORKSPACES OVERLAP, THEN R0 TO R7 ARE SHARED WHEN A CALL FUNCTION OCCURS.
;
;
;

;
;	DEFINE SOME XOP'S DEFINED IN MONITOR
;
	DXOP	PUSHREG,4
	DXOP	POPREG,5	
	DXOP	CALL,6
	DXOP	RET,7
	DXOP	PUSH,8
	DXOP	POP,9
	DXOP	WHEX,10			;WRITE OUT A 16 BIT HEX VALUE
	DXOP	RHEX,11			;READ IN A 16 BIT HEX VALUE
	DXOP	WRITE,12		;WRITE CHAR IN MSB
	DXOP	READ,13			;READ CHAR IN MSB
	DXOP	MESG,14			;OUTPUT NULL TERMINATED MESSAGE
;
;	REGISTER EQUATES
;
R0	EQU	0
R1	EQU	1
R2	EQU	2
R3	EQU	3
R4	EQU	4
R5	EQU	5
R6	EQU	6
R7	EQU	7
R8	EQU	8
R9	EQU	9
R10	EQU	10
R11	EQU	11
R12	EQU	12
R13	EQU	13
R14	EQU	14
R15	EQU	15
;
	AORG	0D800H
;BDOSWP	EQU	84H
;
; BDOS ENTRY POINT
;
	SLA	R2,1			;ADJUST FOR JUMP
	CI	R2,2*40			;MAKE SURE IT A LEGAL VALUE
	JH	EXIT	
	MOV	@FUN00(R2),R0
	B	*R0
;

;#define GETPOS   36  /* get number of current sector */
;#define GOCPM    00  /* go to CP/M */
;#define LSTOUT   05  /* list output */
;#define POSEND   35  /* position file to end */
;#define RDRINP   03  /* reader input */


;
;	JUMP TABLE - ENTER WITH VALUE IN R3
;
FUN00	WORD	BDOS0			;WARM BOOT		
FUN01	WORD	CIN			;CONSOLE INPUT
FUN02	WORD	COUT	 		;CONSOLE OUTPUT (OUTPUT LSB OF R3)
FUN03	WORD	EXIT	
FUN04	WORD	EXIT	
FUN05	WORD	EXIT	
FUN06	WORD	DCONIO			;DIRECT CONSOLE IO		
FUN07	WORD	EXIT	 
FUN08	WORD	EXIT	
FUN09	WORD	EXIT	
FUN10	WORD	EXIT	
FUN11	WORD	EXIT	
FUN12	WORD	EXIT	
FUN13	WORD	EXIT	
FUN14	WORD	DSKFUN			;SELECT A DISK 
FUN15	WORD	FOPEN	 		;OPEN A FILE
FUN16	WORD	FCLOSE	 		;CLOSE A FILE
FUN17	WORD	SEARCH1	 		;LOOK FOR A FILE
FUN18	WORD	SEARCH2			;SEARCH NEXT
FUN19	WORD	ERAFIL	 		;ERASE A FILE
FUN20	WORD	RDSEQ	 		;READ SQUENTIAL
FUN21	WORD	WRSEQ	 		;WRITE SQUENTIAL
FUN22	WORD	MAKFIL	 		;MAKE A FILE
FUN23	WORD	RENAME			;RENAME A FILE	
FUN24	WORD	EXIT	
FUN25	WORD	CDFUNC			;RETURN CURRENT DISK
FUN26	WORD	DMAFUN			;SET DMA ADDRESS
FUN27	WORD	EXIT	 		;
FUN28	WORD	EXIT	 		;
FUN29	WORD	EXIT	 		;
FUN30	WORD	EXIT	 		;
FUN31	WORD	EXIT	 		;
FUN32	WORD	EXIT	 		;
FUN33	WORD	RDRND	 		;READ A RANDOM RECORD
FUN34	WORD	WRRND	 		;WRITE A RANDOM RECORD
FUN35   WORD	GETSIZ			;GET FILE SIZE
FUN36	WORD	SETREL			;SET RELATIVE RECORD
FUN37	WORD	EXIT
FUN38	WORD	EXIT
FUN39	WORD	EXIT
FUN40	WORD	EXIT
EXIT	SETO	R1			;ERROR 
	RET
;
; BIOS EQUATES
;
MONITOR	EQU	0E600H			;MONITOR BASE
TIMON	EQU	0F000H			;DBUG BASE
;
;	BIOS VECTORS ARRANGED AS N*L WHERE
;
;		N IS THE NTH VECTOR IN BIOS, AND
;		L IS THE NUMBER OF BYTES PER VECTOR
;
;
MCONIN	EQU	MONITOR+1*4	;CONSOLE IN
MCONOUT	EQU	MONITOR+2*4	;CONSOLE OUT
MSELDSK	EQU	MONITOR+3*4	;SET CURRENT LOGGED DRIVE
MRDREC	EQU	MONITOR+6*4	;READ A STANDARD RECOR0D
MWRREC	EQU	MONITOR+7*4	;WRITE A STANDARD RECORD
MRECAL	EQU	MONITOR+4*4
MSEEK	EQU	MONITOR+5*4
MRDID	EQU	MONITOR+8*4
MWBOOT	EQU	MONITOR+9*4		;WARM BOOT
;
;
;
;	FCB EQUATES
;
;	THE FCB CONSISTS OF 32 BYTES OF DATA:
;	BYTES 0 TO 31 ARE AN EXACT COPY OF THE DIRECTORY
;
;	   
;	   BYTES	FUNCTION
;	   -----        --------
;	   0 -7		FILENAME
;	   8 -10 	FILENAME EXTENSION
;	   11		FTY  - FILE TYPE	
;	   12-13	FSB  - FILE'S STARTING BLOCK
;	   14-15 	FSZ  - FILE SIZE IN SECTORS
;	   16-17 	FLA  - FILE LOAD ADDRESS - USED TO DETERMINE WHERE FILE WILL LOAD
;	   18-19	FSZBH - FILE SIZE IN BYTES HIGH BYTE
;	   20-21	FSZBL - FILE SIZE IN BYTES LOW BYTE
;	   22-23 	SPARE COULD MAKE THIS DATE - DAYS FROM 1/1/1900)
;	   24-25	CBN  - FILE'S CURRENT BLOCK NUMBER
;	   26-27	CRN  - CURRENT RECORD NUMBER 
;	   28-29	RELB - RELATIVE BLOCK NUMBER
;	   30-31 	RELR - RELATIVE RECORD NUMBER FILE WILL LOAD. 
;	   32		OVERFLOW FOR RELR
;	   33 		DRIVE
;	   34-35 	LBUFCNT - NUMBER BYTES IN LAST BUFFER.  ALLOWS TO MANAGE BINARY FILES AND NOT NEED CPMEOF
;
;	
;	DISC STRUCTURE				    
;	[S1]  [S2]  [S3]  [S4]   [S5]  [S6] ETC   	     <-------FILES BEGIN HERE 
;	[BOOT][BAT1][BAT2][BAT3][DIR1][DIR2][DIR3][DIR4][REC1BLK2,REC2BLK2,RECS3BLK2,REC4BLK2][REC1BLCK3...ETC]
;	 <-----BLOCK 0---------> <-------BLOCK 1--------><-----------BLOCK 2----------------->
;
;	BLOCK ALLOCATION TABLE (BEGINS AT ZERO)
;	BAT SECTOR 1[BLK0,BLK1,BLK2,BLK3.......BLK63] BAT SECTOR 2[BLK64,BLK65,BLK66,BLK67........]
;
;	BAT SECTORS ARE ORGANSISED AS 3 BAT PAGES/SECTOR
;	[PAGE3][PAGE2][PAGE1][ 0 0 0 0 0 0 0 0].  SO THE SHIFT COUNT IS 8 AND MASK IS 0X00FF
;	IE THERE ARE 256 BAT ENTERIES PER 512 BYTES SECTOR (IE 1 WORD PER
;
NAM	EQU	0	
FTY	EQU	11		;TYPE 
FLA	EQU	16		;FILES LOAD ADDRESS
CRN	EQU	26	 	;NEXT RECORD TO READ/WRITE 
CBN	EQU	24	 	;CURRENT BLOCK NUMBER
RELB	EQU	28		;RANDOM ACCESS RELATIVE BLOCK NUMBER
RELR	EQU	30		;RELATIVE RECORD NUMBER
FSB	EQU	12		;FILE STARTING BLOCK
FSZ	EQU	14		;FILE SIZE IN SECTORS
FSZBH	EQU	18		;FILE SIZE IN BYTES HIGH BYTE
FSZBL	EQU	20		;FILE SIZE IN BYTES LOW BYTE
;
; MEDIA TYPE 00FDH
;
TRKDSK	EQU	80			;TRACKS PER DISK
SECTRK	EQU	18			;SECTORS PER TRACK
BYTSEC	EQU	512			;BYTES PER SECTOR
SECBLK	EQU	4			;SECTOR PER BLOCK THIS MEANS THERE ARE 2 BAT SECTORS
					; 80*18*2/SECBLK = 720 IE 2*512 SECTORS REQUIRED
RSVDSEC EQU	1			;RESERVED SECTORS FOR BOOT SECTOR
NSIDES  EQU	2			;NUMBER OF SIDES
SECDSK	EQU	NSIDES*SECTRK*TRKDSK	;SECTORS ON DISK
NBATS	EQU	1			;NO OF BAT ENTRIES ie backup etc
NDSECT	EQU	4			;NO OF DIRECTORY SECTORS PER DISK
FBATSEC EQU	RSVDSEC+1		;FIRST BAT SECTOR  OFFSET FROM 0
FDIRRN	EQU	4			;FIRST DIRECTORY RECORD NUMBER ()
DIRTRK	EQU	0			;DIRECTORY STARTS HERE
BATTRK	EQU	0
BATSF	EQU	8			;DETERMINES THE BAT PAGE (SEE EXPLANATION ABOVE)
BATMSK  EQU	01FFH			;BASED ON BYTSEC/2 USED IN FINBAT
BUFSIZ	EQU	BYTSEC			;DISK BUFFER SIZE
;
NAMSIZ	EQU	11			;FILENAME SIZE IN BYTES
NAMEOFF2 EQU	18			;2ND NAME OFFSET INTO FCB 
DIRSIZ  EQU	32			;NO. OF BYTES PER ENTRY
RDCMD	EQU	1	 		;READ COMMAND
WRCMD	EQU	2	 		;WRITE COMMAND

MINUS1	EQU	-1			;USED FOR GENERAL ERROR
WILD	BYTE	'?'
ALLONES	BYTE	-1			;;USED FOR GENERAL ERROR
	EVEN
;
DISK	WORD	0			;CURRENTLY SELECTED DISK LS BYTE USED
CAB	WORD	0	 		;CURRENTLY ALLOCATED BLOCK NUMBER
CBP   	WORD	0			;CURRENT BAT LOCATION POINTER
CBO	WORD	0			;CURRENT OFFSET INTO BLOCK
CBSECT  WORD	-1			;CURRENT BAT SECTOR IN MEMORY
DIRENT	WORD	0			;USED IN DIRECTORY SEARCH
ADDR	WORD	DIRBUFF			;CURRENT DMA ADDRESS
IOPTR	WORD	0			;CURRENT IOPTR OR DMA ADDRESS FOR MONITOR
TRACK	WORD	0
SECTOR	WORD	0
CDSECT	WORD	0	 		;CURRENT DIRECTORY SECTOR 
CCMD	WORD    0	 		;CURRENT COMMAND
;
;******************************
;
;	WARM BOOT INTERCEPT
;
;*******************************
;
BDOS0	RET
	CLR	R0			;CLEAR CHANGE AND WRITE FLAGS IN BM
	CLR	@BATCHG			;ZERO CAUSES A BATTO BE READ IN
	B	@MWBOOT			;CALL MONITOR
;
;*******************************
;
;	CONSOLE	OUTPUT
;	CHAR IN R3 LSB 
;********************************
;
;
COUT	SWPB	R3			;MOVE CHAR TO UPPER MSB FOR MCONOUT
	MOVB	R3,R2	 		;CHAR IN MSB OF R2
	CALL	@MCONOUT
	RET	
;
;********************************
;
;	CONSOLE	INPUT INTO LSB OF R1
;	NOTE ALL OTHER SYSTEMS USE MSB
;
;********************************
;
CIN	CALL	@MCONIN	 		;INPUT CHAR IN R1
	SWPB	R1
	RET				;RETURN CHAR IN MSB OF R1
;
;-----------------------------------
;
;  DIRECT CONSOLE IO - BYPASS ANY CHARACTER
;  CHECKING.
;
;  IF R3 = FF00H THEN INPUT A CHAR
;  IF R3 = IS LESS THAN 00FFH THEN OUTPUT THE CHAR IN MSB
;
;-----------------------------------------------------
;
DCONIO	MOVB	@ALLONES,R0
	CB	R3,R0
	JEQ	CIN
	JMP	COUT
;
;*************************
;
;	SELECT A DISK
;
;*************************
;
DSKFUN	MOV	R3,R2	 		;FOR MONITOR
	MOV	R3,@DISK
	B	@MSELDSK

;
;*************************
;
;	GET CURRENT DISK
;       RETURN IN MSB OF R1
;
;*************************
;
CDFUNC	MOV	@DISK,R1	 		;FOR MONITOR
	RET

;******************************
;
;	BDOS SET THE DMA ADDRESS
;
;******************************
;
DMAFUN
	MOV	R3,@ADDR		;COPY FOR WRSEQ
	MOV	R3,@IOPTR
	RET
;******************************
;
;	MONITOR SET THE	DMA ADDRESS IN R2
;
;******************************
;
_SETDMA	MOV	R2,@IOPTR
	RET
;
;--------------------------------------------------------------------------
;
;	OPEN A FILE (FUNCTION 15)
;
;	R3 -> FCB
;
;	THIS FUNCION TRANSFERS ALL THE FILE'S  DIRECTORY DATA
;	TO THE FCB.  IF THE FILE IS NOT FOUND -1 IS RETURNED IN
;	REGISTER R1. NOTE THAT THIS FUNCTION WILL NOT CREATE AN
;	ENTRY IF ONE DOESN'T EXIST. 'MAKEFIL(FUNCTION 22) MUST
;	FIRST BE CALLED, HOWEVER IF 'MAKEFIL' IS CALLED THEN
;	OPEN DOES NOT NEED TO BE CALLED EXPLICITLY IN THIS 
;	INSTANCE.
;
;
;----------------------------------------------------------------------------
;
FOPEN	MOV	R3,R8			;COPY FCB POINTER FOR INTERNAL USE
	CALL	@SEARCH1		;OPEN THE DIRECTORY
	MOV	R1,R1			;SUCCESSFUL OPEN ?
	JLT	OPENA	
	MOV	R8,R1
	MOV	R3,R2			;DONT TOUCH DIRECTORY POINTER
	AI	R1,NAMSIZ 		;POINT TO FDE
	AI	R2,NAMSIZ		;R2 -> DIRECTORY ENTRY
	LI	R0,DIRSIZ-NAMSIZ	;NO OF BYTES TO TRANSFER
OPENB	MOVB	*R2+,*R1+		;TRANSFER ENTRIES
	DEC	R0
	JNE	OPENB
;
;  'MAKFIL' ENTERS HERE ALSO
;
OPENENT	CLR	R1
 	MOV	R1,@CBN(R8)		;ZERO CURRENT BLOCK FIELD
	MOV	R1,@CRN(R8)
	MOV	R1,@RELR(R8)
	MOV	R1,@RELB(R8)
	MOV	R1,@FSZBH(R8)
	MOV	R1,@FSZBL(R8)
	RET
OPENA	SETO	R1
	RET
;
;******************************
;
;	CLOSE A	FILE (FUNCTION 16)
;
;	R3 -> FCB
;
;	SIMILAR TO OPEN FUNCTION EXCEPT THAT THE FILE SHOULD 
;	HAVE BEEN PREVIOUSLY EITHER OPENED USING 'OPEN' OR
;	CREATED USING 'MAKFIL'. ANY OTHER METHOD OF CALLING
;	WILL TRANSFER JUNK TO THE DIRECTORY - NOT A PLEASANT 
;	THOUGHT.
;
;	CLOSE ALSO ZERO'S THE CRN & CBN WORDS SO THAT OPEN DOES
;	NOT HAVE TO INITIALISE THESE TWO VALUES.
;
;******************************
;
FCLOSE	MOV	R3,R8			;COPY FCB POINTER
	CALL	@SEARCH1 		;MAKE SURE IT'S HERE 
	MOV	R1,R1	 		;ERROR ?
	JLT	CLOSEB	 		;YES
	MOV	R8,R1			;FCB POINTER
	MOV	R3,R2			;DONT TOUCH R3
	AI	R1,NAMSIZ		;ENTRY DATA POINTER
	AI	R2,NAMSIZ		;DIR ENTRY POINTER
	LI	R0,DIRSIZ-NAMSIZ		
CLOSEA	MOVB	*R1+,*R2+		;UPDATE DIRECTORY ENTRY
	DEC	R0
	JNE	CLOSEA
;	
; UPDATE DIRECTORY ENTRY
;
	CALL	@WRREC	 		;ALL POINTER ARE UNTOUCHED FROM SEARCH1
	CALL	@RECLAIM		;TRY TO RECLAIM UNUSED BLOCKS	
CLOSEB	RET
;
;********************************
;
;	WRITE SEQUENTIALLY (FUNCTION 21)
;
;	R3 -> FCB
;
;	THIS FUNCTION IS CONTROLLED MAINLY BY 
;	THE CRN (NEXT RECORD TO READ) COUNTER.
;
;
;********************************
;
WRSEQ	MOV	R3,R8			;SAVE FCB POINTER
	CALL	@CRNTBC	 		;->CRN TO RELATIVE BLOCK & REMAINDER 
	MOV	R3,@CBO			;SAVE OFFSET
;
;	IF WE COULD TRACE FROM EXISTING POSITION WE COULD SPEED THINGS UP AND STOP THRASHING
;	TRACE1 WILL USE CRN
;
	MOV	R2,R3			;UPDATE
;	WHEX	R2
;	CALL	@TRACES			;TRACE THE BAT LINK  
	CALL	@TRACE
	C	R1,R2			;IF ALLOCATED CONTINUE
	JEQ	WRSEQ0
;
;	AT THIS POINT WE HAVE THE CBP FROM TRACE
;	NXTBLK WILL FIND A BLOCK AND ALLOCATE IT (LINK) 
;	BASED ON CBP
;
	CALL	@NXTBLK	 		;LOCATE A BLOCK AND RETURN IN R7
	MOV	R1,R1			;ANY BLOCKS LEFT ?
	JLT	WRSEQ1			;NO - SHOW ERROR
;
;	IN CASE WE CROSS BAT BOUNDARIES WE NEED TO ALLOCATE LAST BLOCK FIRST
;	AND THEN POSTFIX THE CAB FOUND IN TRACE.  TRACE HAS FILLED THE CBP AND CAB WHICH NEED TO BE UPDATED
;	R7 IS THE CURRENT BLOCK POINTER AND R6= FREE BLOCK NUMBER
;
	LI	R1,0FFF8H		;ALLOCATE THIS BLOCK TO THIS FILE
	MOV	R1,*R7			;NEW END OF LINK IN CURRENT BAT FROM NXTBLK
	MOV	R7,@CBP			;AND KEEP CBP UPDATED
	SETO	@BATCHG			;FORCE AN UPDATE TO THE BAT
	PUSH	R6			;PUSH NEW ALLOCATED BLOCK CAB
;
;	NOW UPDATED PREVIOUS LAST BLOCK
;
	MOV	@CAB,R3			;GET PREVIOUS LAST BLOCK RETURNED FROM TRACE
	CALL	@GETBATP			;FIND THE BAT AND GET THE POINTER FROM THE INDEX
	POP	R6
	MOV	R6,*R7			;UPDATE TO NEW END OF LINK
	MOV	R6,@CAB			;UPDATED FROM NXTBLK
	SETO	@BATCHG			;FORCE AN UPDATE TO THE BAT
;	
WRSEQ0	MOV	@CAB,R2			;RECOVER DISK BLOCK
	MOV	@CBO,R3			;AND OFFSET

	LI	R0,WRCMD
	MOV	R0,@CCMD			;CURRENT COMMAND
	CALL	@RWREC 
	INC	@FSZ(R8) 		;BUMP THE SECTOR COUNT
	INC	@CRN(R8) 		;BUMP CURRENT RECORD
	CLR	R1
	RET
WRSEQ1	SETO	R1	 		;ERROR
	RET
; 
;********************************
;
;	READ SEQUENTIALLY
;       R3 -> FCB
;
;********************************
;
RDSEQ	MOV	R3,R8			;COPY ADDRESS OF FCB
	C	@CRN(R8),@FSZ(R8)	;END OF FILE ?
	JHE	RDSEQ1			;YES
	CALL	@CRNTBC			;CONVERT CRN TO A RELATIVE BLOCK NUMBER
	MOV	R3,@CBO			;SAVE OFFSET AND USE BLOCK IN R2 TO
	CALL	@TRACE			;TRACE THROUGH THE LINKED ALLOCATION LIST
	MOV	@CBO,R3			;RECOVER VARIABLES FOR RWREC
	MOV	@CAB,R2
	LI	R0,RDCMD
	MOV	R0,@CCMD		;CURRENT COMMAND
	CALL	@RWREC
	INC	@CRN(R8)		;BUMP TO NEXT RECORD 
	CLR	R1
	RET
RDSEQ1	SETO	R1
	RET
;
;*******************************
;
;	READ RANDOM RECORD
;
;********************************
;
RDRND	MOV	@RELB(R3),@CBN(R3)		;TRANSER RECORD NUMBER
	MOV	@RELR(R3),@CRN(R3)
	CALL	@RDSEQ
	DEC	@CRN(R8)			;READ RANDOM CAN'T INCREMENT THE CRN
	RET
;
;*******************************
;
;	WRITE RANDOM RECORD
;	R3 -> FCB
;       (R3)RELR  MUST HOLD THE RECORD TO WRITE TO
;
;*******************************
;
WRRND	MOV	@RELB(R3),@CBN(R3)		;TRANSEFER RECORD NUMBER
	MOV	@RELR(R3),@CRN(R3)
	JMP	WRSEQ				;NORMAL SEQUENTIAL WRITE
;
;*******************************
;
;	COMMON READ WRITE ENTRY
;
;	R8 --> FCB
;	R2 = DISK BLOCK
;	R3 = RECORD OFFSET
;*******************************
;
RWREC	MOV	R2,R1			;BLOCK TO CONVERT
	CALL	@BTTSC	 		;CONVERT BLOCK TO TRK/SECT(R2/R3) 
	PUSH	R3			;PUSH SECTOR
	CALL	@SETTRK			;R2 HOLDS TRACK
	POP	R2			;SECTOR
	CALL	@SETSEC	
	MOV	@ADDR,R2		;THIS IS THE LOCAL COPY OF DMA ADDR
	CALL	@_SETDMA		;CAUGHT WITH CALLS THROUGH DMAFUN VALUE IN R4 FOR MONITOR
	MOV	@CCMD,R0		;GET TYPE
	CI	R0,WRCMD		;READ ? 
	JNE	RWRECA	 	;TRY FOR WRITE
	B	@WRREC	 	;RETURN FROM RDREC
RWRECA	B	@RDREC	 	;ASSSUME READ
;
;*******************************	
;
;	SEARCH FIRST( LOOK FOR DIRECTORY ENTRY)
;
;	NORMAL DIRECTORY SEARCH BEGINNING AT THE
;	START OF THE DIRECTORY CONTINUING TILL END.
;
;	E5 => DELETED ENTRY	
;	00 => END OF DIRECTORY	
;	R3 -> FCB	
;
;	RETURN 
;		R1 =  MINUS ONE FOR BAD RESULT 
;		R3 -> CURRENT DIRECTORY ENTRY
;
;********************************	
;
SEARCH1	MOV	R3,R8			;SAVE FCB
	SETO	@DIRENT			;SET CURRENT SECTOR DIRECTORY INDEX
	CLR	@CDSECT			;BEGIN SEARCHING AT FIRST SECTOR
	CALL	@DIROPN	 		;OPEN THE DIRECTORY
	JMP	DLOOK			;RETURN FROM DLOOK
;
;***********************************
;
;	SEARCH NEXT (SEARCH2)
;
;	SIMILAR TO CPM - BASICALLY CONTINUES
;	WHERE LAST SEARCH LEFT OFF. THAT IS IT 
;	SIMPLY DOES NOT ALTER THE VALUE OF THE 
;	DIRENT AND CDSECT VARIABLES.
;
;************************************
;
SEARCH2	MOV	R3,R8
	CALL	@DIROPN			;OPEN THE DIRECTORY
	JMP	DLOOK
;
;-------------------------------------------------
;
;  FUCTION 35 - GET FILE SIZE
;
;   R2 = FUNCTION NUMBER
;   R3 -> FCB
;
;   PURPOSE - MOVE THE ADDRESS OF THE LAST RECORD
;	      TO THE RELATIVE FIELDS
;
;-------------------------------------------------
;
GETSIZ	MOV	R3,R8			;COPY FCB POINTER FOR INTERNAL USE
	CALL	@SEARCH1		;OPEN THE DIRECTORY
	MOV	R1,R1			;SUCCESSFUL OPEN ?
	JLT	GETSIZ1	
	MOV	@FSZ(R8),@RELR(R8)	;TRANSFER THE FILE SIZE
GETSIZ1	RET
;
;--------------------------------------------------
;
;  FUCTION 36 - SET RELATIVE RECORD
;   R2 =  FUNCTION NUMBER
;   R3 -> FCB
;
;   PURPOSE - THE RELATIVE RECORD FIELD IS SET TO THE
;             SAME FILE ADDRESS AS THE CURRENT BLOCK AND
;             CURRENT RECORD.
;
;---------------------------------------------------
;
SETREL	MOV	@CBN(R3),@RELB(R3)		;TRANSFER RECORD POINTERS
	MOV	@CRN(R3),@RELR(R3)
	RET
;
;*****************************************
;
;	GENERAL DIRECTORY SEARCH SUBROUTINE
;	R8 = PTR TO FCB
;	MUST CHECK FILE ATTRIBUTES FOR FILE TYPE
;
;******************************************
;
DLOOK	CALL	@DIRBLK	 		;GET NEXT ENTRY PNTR IN R3
	JLT	NONTRY	 		;NOT FOUND
DLOOK1	MOV	R3,R2	 		;SAVE PNTR
	MOVB	*R2,R0	 		;TEST FOR EOD
	JLT	DLOOK	 		;DELETED ENTRY 
	JGT	DLOOK4	 		;VALID
	CLR	R3	 		;SHOW END OF DIRECTORY REACHED 
	JMP	NONTRY	
DLOOK4	LI	R0,NAMSIZ 		;NUMBER OF CHARS TO MATCH
	MOV	R8,R5			;SAVE FCB PNTR 
NXTLTR	CB	*R5,@WILD		;? WILL MATCH ALL (LIKE CPM)
	JNE	DLOOK5			;PROCESS NORMALLY
	INC	R5			;ELSE ASSUME MATCH SO BUMP POINTERS
	INC	R2
	JMP	DLOOK6
DLOOK5	CB	*R2+,*R5+		;MATCH ?
	JNE	DLOOK	 		;NO SO - KEEP LOOKING
DLOOK6	DEC	R0	
	JNE	NXTLTR	 		;CONTINUE
	CLR	R1	 		;SHOW GOOD RESULT
	RET	
NONTRY	SETO	R1	 
	RET				;SHOW NOT FOUND
;
;********************************	
;
;	CREATE A DIRECTORY ENTRY (FUNCTION 22)
;
;	ENTRY: 	R3 -> FCB
;		R2 = 22
;
;	RETURN: R1 = 0 EMPTY DIRECTORY FOUND
;		R1 = FF NO EMPTY DIRECTORY AVAILABLE
;
;	THIS FUNCTION SHOULD BE CALLED ONLY WITH THE
;	FILENAME IN THE FIRST 10 BYTES OF THE FCB. 'MAKFIL'
;	MAKES A POINT OF ZEROING ALL BAR THE FILENAME WITH
;	THE DIRECTORY ENTRY BEFORE WRITING IT TO DISK. HENCE
;	YOU MUST CALL CLOSE TO PROPERLY TRANSFER ANY FILE 
;	ATTRIBUTES ETC. ALSO NOTE THAT THE FSB WILL BE RETURNED
;	HOWEVER ALL OTHER FCB ENTRIES WILL BE ZEROED.
;
;
;******************************	
;
MAKFIL	MOV	R3,R8			;LOCAL FCB COPY
	CALL	@NXTBLK	 		;FIND A SECTOR FOR FSB AND PLACE IN CAB
	MOV	R1,R1	 		;ERROR ?
	JLT	MAKERR			;LOOKS LIKE DISK FULL 
 	MOV	R6,@CAB			;UPDATE BLOCK VECTORS ETC
	MOV	R7,@CBP
	SETO	@DIRENT			;SIMILAR TO SEARCH1
	CLR	@CDSECT			;MUST SET THESE VARIABLES
	CALL	@DIROPN	 		;OPEN THE DIRECTORY
NTHR	CALL	@DIRBLK	 		;GET ENTRY THROUGH R3
	JLT	MAKERR			;END OF DIRECTORY
	MOVB	*R3,R0	 		;CHECK ENTRY
	JGT	NTHR	 		;VALID ENTRY
;
; ASSUME R3 POINTS TO DIR ENTRY
;
	CLR	R0
	MOV	R8,R5
	AI	R5,FTY			;FLUSH FROM FILE TYPE ENTRY
	LI	R2,DIRSIZ-NAMSIZ		;NUMBER OF BYTES TO ZERO
MKFIL2	MOVB	R0,*R5+
	DEC	R2
	JNE	MKFIL2
	MOV	@CAB,@FSB(R8)		;TRANSFER FSB
	LI	R1,0FFF8H		;MARK AS FIRST AND LAST BLOCK IN BAT
	MOV	@CBP,R0
	MOV	R1,*R0			;SHOW ITS THE LAST BLOCK AS WELL AS THE FIRST
;
; NOW CREATE THE ZERO FILE
;
	LI	R2,DIRSIZ		;TRANSFER FILENAME + FSB TO DIRECTORY
	MOV	R8,R5	 		;SAVE FCB VECTOR
MKFIL1	MOVB	*R5+,*R3+		;TRANSER FCB ENTRY TO DIRECTRY
	DEC	R2	
	JNE	MKFIL1	
	CALL	@WRREC			;WRITE THE DIRECTORY
	CALL	@WRBAT	 		;UPDATE BAT AS DIRECTORY ENTRY IS VALID
	MOV	R1,R1			;IF NO ERROR SIMULATE 'OPEN'
	JLT	MAKERR
	B	@OPENENT
MAKERR	SETO	R1 
	RET
;
;*************************************************
;
;  RENAME A FILE
;
;  R3 -> FCB   BYTES 0 - 17  OLD NAME
;	       BYTES 18- 27  NEW NAME 
;
;*************************************************
;
RENAME	MOV	R3,R8
	CALL	@SEARCH1		;CHECK TO SEE IF THE FILE EXITS
	MOV	R1,R1
	JLT	RENAM2			;NOT FOUND	
	LI	R0,NAMSIZ		;FILENAME SIZE	
	MOV	R3,R2			;R2 -> DIRECTORY ENTRY
	MOV	R8,R1
	AI	R1,NAMEOFF2		;POINT TO 2ND FILE NAME
RENAM1	MOVB	*R1+,*R2+		;COPY NEW FILE NAME OVER OLD ONE
	DEC	R0
	JNE	RENAM1			;JUMP IF NOT DONE
;
; NOW WRITE THE NEW DIRECTORY ENTRY BACK
;
	CALL	@WRREC			;ALL DIRECTORY POINTERS UNTOUCHED FROM SEARCH1
RENAM2	RET
;
;******************************
;
;	ERASE A	DIRECTORY ENTRY
;
;	R3 -> FCB
;
;	ON RETURN R1 = 0 FOR DIRECTORY ENTRY FOUND
;		     = -1 FOR NO DIRECTORY ENTRY FOUND
;
;*******************************
;
ERAFIL	MOV	R3,R8
	CALL	@SEARCH1 		;LOOK FOR THE FILE ENTRY
	MOV	R1,R1	 		;DID WE FIND IT ?
	JLT	ERAERR	 		;NO
	LI	R1,8000H			;R3->DIR ENTRY
	SOCB	R1,@NAM(R3)		;MAKE DELETED
	MOV	@FSB(R3),@FSB(R8)		;NB RECOVER BAT POINTER
	CLR	@FSZ(R8)			;FORCE RE-ALLOCATION OF USED BLOCK
	CALL	@WRREC	 		;WRITE FDE BACK TO DISK
;
;---NOW	RELEASE	ALLOCATED BLOCKS
;
RECLAIM CLR	R3			;START AT FIRST BAT SECTOR
	CALL	@GETBATP 		;READ IN THE BAT TABLE
	MOV	@FSZ(R8),R3		;GET FILE SIZE FOR AND
	CALL	@RECTBC			;CONVERT FILE SIZE TO BLOCKS
	CALL	@TRACE			;TRACE THROUGH TO TO BLOCK NUMBER
	LI	R1,0FFF8H
	MOV	*R7,R3			;RECOVER BAT INDEX
	MOV	R1,*R7			;ASSUME LAST LINK ENTRY
	MOV	@FSZ(R8),R0		;ZERO FILE SIZE IE RECLAIM ALL BLOCKS?
	JNE	ERA00			;NO
	CLR	*R7			;YES SO ZERO LAST LINK
ERA00	C	R3,R1			;LAST LINK ?
	JEQ	ERA02			;YES
ERA01	CALL	@GETBATP			;GET INDEX (IN R5) TO NEXT BAT
	MOV	*R7,R3 			;NEXT INDEX VALUE
	CLR	*R7			;ZERO TO SHOW BLOCK IS FREE
	C	R3,R1			;CHECK FOR FINAL LINK
	JEQ	ERA02			;YES - SO WE'RE FINISHED
	JMP	ERA01			;KEEP GOING
ERA02	CALL	@WRBAT			;UPDATE DISK VERSION OF BAT
	CLR	R1			;DONE
	RET	
ERAERR	SETO	R1
	RET
;
;*********************************
;
;	READ IN THE DIRECTORY
;
;	R8 -> FCB	
;
;*********************************
;
DIROPN	MOV	@CDSECT,R3		;ASSUME THIS HAS BEEN SET
	AI	R3,FDIRRN		;FIRST DIRECTORY RECORD NUMBER
	CALL	@RECTBC			;CONVERT TO A BLOCK NUMBER
	MOV	R2,R1			;BLOCK TO FIND
	CALL	@BTTSC			;CONVERT TO TRACK/SECTOR
	PUSH	R3			;PUSH SECTOR
	CALL	@SETTRK			;BIOS CALL
	POP	R2			;SET SECTOR TO READ
	CALL	@SETSEC
	LI	R2,DIRBUFF 		;BUFFER TO USE
	CALL	@_SETDMA	 	;BIOS DMA
	CALL	@RDREC	 		;READ IN DIRECTORY
	LI	R3,DIRBUFF		;USE SAME BUFFER 
	RET
;
;	FIND THE NEXT DIRECTORY ENTRY
;	DIRENT IS JUST AN OFFSET INTO THE 
;	DIRECTORY BUFFER. ITS VALUUE DEPENDS ON 
;	THE BLOCK SIZE.
;
;	R3 -> TO FILE DIRECTORY CONTENTS
;
DIRBLK	INC	@DIRENT	 		;UP THE LAST ENTRY
	MOV	@DIRENT,R3
	SLA	R3,5			;*32 IE 32 BYTES DIRECTORY ENTRY
	AI	R3,DIRBUFF		;POINT TO NEXT ENTRY
	CI	R3,DIRBUFF+BUFSIZ	;HAVE WE REACHED THE END OF THE BUFFER
	JL	DIRB01			;NO
	INC	@CDSECT	 		;NOW - TRY NEXT SECTOR
	MOV	@CDSECT,R3		;R3 HOLDS RECORD OFFSET WITHIN BLOCK
	CI	R3,NDSECT		;NUMBER OF SECTORS ALLOCATED TO DIRECTORY
	JHE	DIRB03			;SHOW END OF DIRECTORY
	AI	R3,FDIRRN		;FIRST DIRECTORY RECORD NUMBER
	CALL	@RECTBC			;CONVERT TO A BLOCK NUMBER
	MOV	R2,R1			;BLOCK TO FIND
	CALL	@BTTSC			;CONVERT TO TRACK/SECTOR
	PUSH	R3			;PUSH SECTOR
	CALL	@SETTRK			;BIOS CALL TO SET TRACK
	POP	R2			;POP SECTOR	
	CALL	@SETSEC			;BIOS CALL TO SET SECTOR
	LI	R2,DIRBUFF		;UPDATE DMA ADDRESS
	CALL	@_SETDMA
	CALL	@RDREC	 		;READ NEXT SECTOR
;
;SHOULD THIS BE SET TO ONE OR CLR'D?
;	CLR	@DIRENT			;RESET FOR NEXT TIME
	SETO	@DIRENT			;RESET FOR NEXT TIME
	LI	R3,DIRBUFF		;-->DIRECTORY ENTRY
DIRB01	CLR	R1			;FLAG SET
DIRB02	MOV	R1,R1	 		;SET STATUS
	RET
DIRB03	SETO	R1
	JMP	DIRB02
;
;******************************
;
;	CONVERT CRN TO BLOCK NUMBER (CRNTBC)
;
;	THIS ROUTINE SIMPLY DIVIDES RECORD NUMBER
;	BY BLOCK SIZE TO GIVE A RELATIVE BLOCK NO
;	SO THAT THE BAT MAY BE INDEXED VIA RESULT
;	IN R2.
;
;*******************************
;
CRNTBC	MOV	@CRN(R8),R3 		;NEXT RECORD TO READ
;
;	ENTER HERE IF GENERAL RELATIVE CONVERSION REQUIRED
;	R3 MUST HOLD RECORD NUMBER - NOTE RELATIVE OFFSET WITHIN BLOCK IS FOUND
;	RECORDS BEGIN AT 1
;	BLOCKS BEGIN AT 0
;
RECTBC	CLR	R2	 		;FOR DIVIDE
	LI	R0,SECBLK	 	;SECTORS/BLOCK
	DIV	R0,R2	 		;R2 & R3 HOLD RESULT
RECTBC1	RET
;
;------------------------------------------------------------------------
;
;	BLOCK NO. TO TRK/SECT CONVERSION
;
;	THIS ROUTINE WILL CONVERT A GIVEN BLOCK AND
;	AND RECORD NUMBER WITHIN A FILE TO A PHYSICAL
;	TRACK AND SECTOR. I.E. YOU MAY WISH TO LOCATE
;	THE TRACK/SECTOR OF SAY RECORD 3 WITHIN BLOCK
;	10 ETC.
;
;	THIS ROUTINE IS NORMALLY CALLED AFTER A CALL
;	TO CRNTBC/RECTBC WITHIN RDSEQ ,WRSEQ ETC.
;
;	R1 = BLOCK NO.
;	R3 = RECORD OFFSET WITHIN BLOCK
;
;	RECORDS BEGIN AT 1
;	BLOCKS BEGIN AT 0
;
;	RETURN WITH R2=TRACK,R3=SECTOR
;
;	TRK = INT((BLK*SECBLK + R3)/SECTRK)
;	SECT = REMAINDER(BLK...)+1		
;
;	R2 = TRK, R3 = SECT
;
; NOTE NEEDED TO REMOVE THE MULTIPY AS IF HAS A BUG.  SEE 99105 ERRATA
;------------------------------------------------------------------------
;
;REVISED MULTIPLY TO AVOID 99105 MULTIPLY BUG
;

BTTSC	LI	R0,SECBLK
	CLR	R2
	JEQ	BTTSC2
BTTSC1	A	R1,R2		;R2=BLK*SECBLK 
	DEC	R0
	JNE	BTTSC1
BTTSC2	A	R2,R3		;R3=BLK*SECBLK+R3
	CLR	R2		;MSB OF QUOTIENT
	LI	R0,SECTRK	;SECTORS/TRACK
	DIV	R0,R2	 	;R2=TRK,R3=SECT (R2+R3)/R0
	INC	R3		;TAKES CARE OF ZERO OFFSET FOR CRN
BTTSC0	RET
;
;*******************************
;
;	
;	FIND A FREE BLOCK	
;	NXTBLK WILL TRAVERSE THE BAT LOOKING FOR A ZEROED
;	BAT ENTRY.  ONCE FOUND NO CHANGE TO THE BAT WILL BE
;	MADE AND ONLY THE POINTERS TO THE ENTRY WILL BE RETURNED.
;	IT IS THEN UP TO THE CALLING PROGRAMME TO INSERT THE NEW
;	LINKS.
;
;	NOTE: RDBAT WILL PULL IN THE APPROPRIATE BAT SECTOR AS REQUIRED
;
;	R8 -> FCB
;
;	R1 = -1 (ERROR)
;	R1 = 0  (GOOD RESULT)
;	
;*******************************
;NOTE: RDBAT WILL PULL IN THE APPROPRIATE BAT SECTOR AS REQUIRED
;************************************************
;
NXTBLK	MOV	@CAB,R0			;BEGIN AT LAST BLOCK TO SPEED THINGS UP AND TO STOP THRASHING
					;TO TO LOOK AT LATER WRAPPING BACK TO BEGINING
;
NXTBLK2	MOV	R0,R3
	CALL	@GETBATP			;FIND THE BAT AND GET THE POINTER FROM THE INDEX
	MOV	*R7,R1			;POINTER IS IN R7
	JEQ	NXTBLK4			;ANY FREE ? YES
	CI	R1,-1			;LAST AVAILABLE BLOCK ?
	JEQ	NXTBLK3			;YES
	INC	R0			;NEXT BLOCK
	JMP	NXTBLK2			;KEEP LOOKING
;
; R7 -> FREE BLOCK
; R6 =  FREE BLOCK NUMBER
;
NXTBLK4	MOV	R0,R6			;COPY FREE BLOCK NUMBER HERE	
;	PUSHREG	R7
;	WHEX	R0
;	WHEX	R7
;	POPREG	R7
	CLR	R1			;SHOW SUCCESS
NXTBLK3	MOV	R1,R1			;RETURN WITH RESULT CONDINTION SET
	RET 
;
;****************************
;
;	READ A RANDOM RECORD 
;
;******************************
;
RDREC	PUSH	R8	 		;SAVE FCB 
	MOV	@TRACK,R3
	CALL	@MSEEK
	MOV	@IOPTR,R4
	MOV	@SECTOR,R3
	CALL	@MRDREC	 		;READ THE RECORD IN
	POP	R8	
	MOV	R1,R1	 		;ERROR ?
	JEQ	RDREC1	 		;YES
	SETO	R1	 		;SHOW ERROR
RDREC1	RET	
;
;******************************
;
;	WRITE A	RANDOM RECORD
;
;*****************************
;
WRREC	PUSH	R8	 		;SAVE FCB PNTR
	MOV	@TRACK,R3
	CALL	@MSEEK
	MOV	@IOPTR,R4
	MOV	@SECTOR,R3
	CALL	@MWRREC	
	POP	R8
	MOV	R1,R1	
	JEQ	WRREC1	
	SETO	R1
WRREC1	RET
;
;*************************************************
;*
;*   TRACE THE FILES LINKED LIST AND FIND THE 
;*   BAT ENTRY CORRESPONDING TO THE FILES NTH 
;*   BLOCK.
;*   ENTER WITH FILES RELATIVE RECORD IN R2 (SET TO -1 IF LAST LINK REQUIRED)
;*   EXIT  WITH DBN (DISK BLOCK NUMBER ) POINTER IN R7
;*   AND WITH R1=R2 IF MATCH TO R1 AND R1=0FFF8 IF LAST LINK
;*
;*   CALL TRACES WITH FSB/CAB DURING WRSEQ TO SPEED UP TRACE
;*
;**************************************************
;
TRACE   	MOV	@FSB(R8),R3		;GET FIRST BLOCK IN LINK
TRACES	CLR	R1			;COUNTER
TRACE1   CALL	@GETBATP			;GET THE BLOCK POINTER TO REQUESTED BAT ENTRY
	MOV	*R7,R4			;GET NEXT ALLOCATION LINK
	CI	R4,0FFF8H		;IS IT THE LAST BLOCK ?
	JEQ	TRACE3			;YES
	C	R1,R2			;HAVE WE REACHED THE WANTED BLOCK YET ?
	JEQ	TRACE3			;YES
	INC	R1			;BUMP THE RECORD POINTER
	MOV	R4,R3			;GET THE LINK AND KEEP GOING
	JEQ	TRACE2			;CAN'T IMAGINE WHY ?
	JMP	TRACE1
TRACE2	SETO	R1
	RET
TRACE3  	MOV	R7,@CBP			;CURRENT BLOCK POINTER
	MOV	R3,@CAB			;AND CURRENT NUMBER
	RET
;
; GETBATP (GET BAT POINTER) CHECK TO SEE IF THE BAT INDEX PASSED
; IN R3 LIES WITHIN THE RANGE OF THE CURRENT
; BAT WHICH IS IN MEMORY. IF NOT IT WILL READ
; THE APPRORIATE BAT INTO THE BUFFER
; R7 WILL BE RETURNED AS A POINTER TO THE INDEXED ELEMENT
; REGISTERS R0->R5 ARE PRESERVED
;
GETBATP PUSHREG	R5
	MOV	R3,R0
	SRL	R0,BATSF			;DETERMINE CURRENT BAT PAGE OR SECTOR BASED ON 256 PER SECT
	C	R0,@CBSECT		;CURRENT BAT IN MEMORY
	JEQ	FBAT0			;IN MEMORY
	MOV	R0,R1			;BAT SECTOR TO BE READ IN
	CALL	@RDBAT			;UPDATE MEMORY VERSION OF BAT
;
;	WE HAVE CROSSED TO ANOTHER BAT PAGE, NEED TO ADJUST
;
FBAT0   POPREG	R5			;NEED TO POP HERE TO GET R3
	MOV	R3,R7
	SLA	R7,1			;TWO BYTES PER ENTRY AND MAKES IT WORD EVEN
	ANDI	R7,BATMSK		;MASK HIGH BITS	
	AI	R7,BATBUFF		;R7->INDEXED ELEMENT
	RET				;ALL IS OKAY
;
;	READ IN THE BAT
;	R1 HOLDS CURRENT BAT SECTOR TO READ IN 
;	DON'T CHECK IF ALREADY IN MEMORY AS THE CALLING ROUTINE WILL DO THAT
;	R1=0 FOR 1ST 1 FOR 2ND ETC
;
RDBAT	MOV	@BATCHG,R0		;IF THERE HAS BEEN A CHANGE FIRST UPDATE
	INC	R0
	JNE	RDBAT1			;NO CHANGE SO PERFORM AS REQUESTED
;
;	WRITE MODIFIED BAT TO DISC
;
RDBAT0	C	R1,@CBSECT		;IF SECTOR IN MEMORY EXIT
	JEQ	RDBAT2
	PUSH	R1			;CHANGE SO DON'T READ IF IF NOT NECESSARY
	CALL	@WRBAT			;FORCE UPDATE OF DISK BAT
	POP	R1
RDBAT1	MOV	R1,@CBSECT		;NEW SECTOR
	LI	R2,BATTRK 		;FIXED BAT TRACK 
	CALL	@SETTRK
	MOV	R1,R2			;SECTOR N
	AI	R2,FBATSEC		;OFFSET FROM BAT START
	CALL	@SETSEC
	LI	R2,BATBUFF 		;USE THIS BUFFER
	CALL	@_SETDMA
	CALL	@RDREC	 		;READ IN BAT
RDBAT2	RET
;
;	WRITE OUT A BAT SECTOR
;	CBSECT HOLDS BAT SECTOR TO BE WRITTEN TO DISK
;
WRBAT	LI	R2,BATTRK  		;TRACK 0
	CALL	@SETTRK
	MOV	@CBSECT,R2 		;SECTOR
	AI	R2,FBATSEC
	CALL	@SETSEC
	LI	R2,BATBUFF		;USE SAME BUFFER 
	CALL	@_SETDMA
	CALL	@WRREC
	CLR	@BATCHG			;DISK BM NOW EQUALS MEMORY VERSION
WRBAT1	RET
;
;	SET THE TRACK TO BE USED (R2)
;
SETTRK	CI	R2,TRKDSK		;CHECK FOR SIDE 2
	JLT	SETTRK1	
	AI	R2,-2*TRKDSK
	INC	R2
	NEG	R2
	ORI	R2,8000H		;SET MSB TO INDICATE SIDE 1
SETTRK1	MOV	R2,@TRACK
	RET
;
;
;
;	SET THE SECTOR TO BE USED
;
SETSEC	MOV	R2,@SECTOR
	RET
;
;
;	BUFFERS ETC
;
;	THE FLAG BATCHG(BIT MAP CHANGE) IS SET WHENEVER AN ALLOCATION
;	BIT IN THE BLOCK ALLOCATION TABLE (BAT)HAS BEEN 
;	CLEARED/ALLOCATED. THIS ACTION THEREBY ENSURES THAT THE BAT
;	WILL NOT BE OVERWRITTEN BY THE DISK VERSION OF THE BIT MAP.
;	THIS FLAG IS CLEARED ONCE A BIT MAP DISK WRITE IS FORCED BY
;	A FILE CLOSURE OR A DIRECTORY FSB BEING REQUESTED.
;
BATCHG	WORD	0		;BAT CHANGE FLAG
BATBUFF BSS	BUFSIZ		;BAT BUFFER
DIRBUFF BSS	BUFSIZ		;DIRECTORY BUFFER
INTBUFF BSS	BUFSIZ		;BUFFER FOR C COMPILED PROGRAMMES
;
	END

