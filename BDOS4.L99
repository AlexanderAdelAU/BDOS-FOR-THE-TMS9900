                        ;
                        ;---------------------------------------------------------
                        ;
                        ;	BDOS FOR THE 9900/99000
                        ;
                        ;	WRITTEN	BY ALEXANDER.CAMERON
                        ;
                        ;	DURING JULY 1983.
                        
                        ;	18 NOV 2019	BDOS IS CONFIGURED TO SHARE CALLING PROGRAMME WORKSPACE AND STACK
                        ;		THAT IS IT DOES NOT DEFINE ITS OWN STACK
                        ;	25 MAY 2024	NEW VERSION 3 TO INCORPORATE IDE HARD DRIVE - FLOPPY I/F WILL BE REMOVED
                        ;	26 AUGUST 2024	NEW VERSION 4 TO ADD MODULE LOAD CAPABILITY TO ALLOW FOR SEGMENTED MEMORY
                        ;
                        ;
                        ;-----------------------------------------------------------
                        ;
                        ; DEFINE XOP FUNCTIONS
                        ; THESE XOP ARE DEFINED IN THE MONITOR.
                        ; BECAUSE THE XOP WORKSPACES OVERLAP,
                        ; THEN R0 TO R7 ARE SHARED WHEN A CALL FUNCTION OCCURS.
                        ;
                        ;
                        ;
                        ;
                        ;	DEFINE SOME XOP'S DEFINED IN MONITOR
                        ;
                        	DXOP	NEWPAGE,2
                        	DXOP	SWPAGE,3
                        	DXOP	PUSHREG,4
                        	DXOP	POPREG,5
                        	DXOP	CALL,6
                        	DXOP	RET,7
                        	DXOP	PUSH,8
                        	DXOP	POP,9
                        	DXOP	WHEX,10		;WRITE OUT A 16 BIT HEX VALUE
                        ;	DXOP	RHEX,11		;READ IN A 16 BIT HEX VALUE
                        ;	DXOP	WRITE,12		;WRITE CHAR IN MSB
                        ;	DXOP	READ,13		;READ CHAR IN MSB
                        ;	DXOP	MESG,14		;OUTPUT NULL TERMINATED MESSAGE
                        	DXOP	DEBUG,15
                        ;
                        ;	REGISTER EQUATES
                        ;
  0000                  R0	EQU	0
  0001                  R1	EQU	1
  0002                  R2	EQU	2
  0003                  R3	EQU	3
  0004                  R4	EQU	4
  0005                  R5	EQU	5
  0006                  R6	EQU	6
  0007                  R7	EQU	7
  0008                  R8	EQU	8
                        
                        ;
                        ; OPERATING SYSTEM EQUATES
                        ;
  F000                  MONITOR	EQU	0F000H
  D100                  BDOS	EQU	0D100H
                        ;		;
  D100                  	AORG	BDOS
                        ;
                        ; BDOS ENTRY POINT;  BDOS IS CALLED VIA XOP CALL SO THAT
                        ;
  D100   0A12           	SLA	R2,1		;ADJUST FOR JUMP
  D102   0282 0050      	CI	R2,2*40		;MAKE SURE IT A LEGAL VALUE
  D106   1B2C           	JH	EXIT	
  D108   C022 D10E      	MOV	@FUN00(R2),R0
  D10C   0450           	B	*R0
                        ;
                        
                        ;#define GETPOS   36  /* get number of current sector */
                        ;#define GOCPM    00  /* go to CP/M */
                        ;#define LSTOUT   05  /* list output */
                        ;#define POSEND   35  /* position file to end */
                        ;#define RDRINP   03  /* reader input */
                        
                        
                        ;
                        ;	JUMP TABLE - ENTER WITH VALUE IN R3
                        ;
  D10E   D17E           FUN00	WORD	BDOS0			;WARM BOOT		
  D110   D194           FUN01	WORD	CIN			;CONSOLE INPUT
  D112   D18A           FUN02	WORD	COUT	 		;CONSOLE OUTPUT (OUTPUT LSB OF R3)
  D114   D160           FUN03	WORD	EXIT	
  D116   D160           FUN04	WORD	EXIT	
  D118   D160           FUN05	WORD	EXIT	
  D11A   D19C           FUN06	WORD	DCONIO			;DIRECT CONSOLE IO		
  D11C   D160           FUN07	WORD	EXIT	 
  D11E   D160           FUN08	WORD	EXIT	
  D120   D160           FUN09	WORD	EXIT	
  D122   D160           FUN10	WORD	EXIT	
  D124   D160           FUN11	WORD	EXIT	
  D126   D160           FUN12	WORD	EXIT	
  D128   D160           FUN13	WORD	EXIT	
  D12A   D1A6           FUN14	WORD	DSKFUN			;SELECT A DISK 
  D12C   D1D0           FUN15	WORD	FOPEN	 		;OPEN A FILE
  D12E   D260           FUN16	WORD	FCLOSE	 		;CLOSE A FILE
  D130   D368           FUN17	WORD	SEARCH1	 		;LOOK FOR A FILE
  D132   D378           FUN18	WORD	SEARCH2			;SEARCH NEXT
  D134   D460           FUN19	WORD	ERAFIL	 		;ERASE A FILE
  D136   D2EE           FUN20	WORD	RDSEQ	 		;READ SQUENTIAL
  D138   D28A           FUN21	WORD	WRSEQ	 		;WRITE SQUENTIAL
  D13A   D3D4           FUN22	WORD	MAKFIL	 		;MAKE A FILE
  D13C   D43E           FUN23	WORD	RENAME			;RENAME A FILE	
  D13E   D160           FUN24	WORD	EXIT	
  D140   D1B0           FUN25	WORD	CDFUNC			;RETURN CURRENT DISK
  D142   D1B6           FUN26	WORD	DMAFUN			;SET DMA ADDRESS
  D144   D1C6           FUN27	WORD	MLOAD	 		;LOAD MODULES FROM TABLE
  D146   D160           FUN28	WORD	EXIT	 		;
  D148   D160           FUN29	WORD	EXIT	 		;
  D14A   D160           FUN30	WORD	EXIT	 		;
  D14C   D160           FUN31	WORD	EXIT	 		;
  D14E   D160           FUN32	WORD	EXIT	 		;
  D150   D324           FUN33	WORD	RDRND	 		;READ A RANDOM RECORD
  D152   D33A           FUN34	WORD	WRRND	 		;WRITE A RANDOM RECORD
  D154   D380           FUN35	WORD	GETSIZ			;GET FILE SIZE
  D156   D392           FUN36	WORD	SETREL			;SET RELATIVE RECORD
  D158   D160           FUN37	WORD	EXIT
  D15A   D160           FUN38	WORD	EXIT
  D15C   D160           FUN39	WORD	EXIT
  D15E   D160           FUN40	WORD	EXIT
  D160   0701           EXIT	SETO	R1			;ERROR 
  D162   2DC0           	RET
                        
                        ;
                        ; BIOS EQUATES
                        ;
                        ;
                        ;TEMPORARY TESTING ADDRESS TO MIMIC MONITOR BEING AT LOCATION F000
  0086                  MON_PTR	EQU	086H			;LOW MEMORY POINTER TO MONITOR
                        ;
                        ;	BIOS VECTORS ARRANGED AS N*L WHERE
                        ;
                        ;	N IS THE NTH VECTOR IN THE MONITOR, AND
                        ;	L IS THE NUMBER OF BYTES PER VECTOR
                        ;
                        ;	WHEN CALLING MRDREC, MWRREC ETC IT IS NECESSARY TO CALL USING
                        ;	LBA VALUES, NOT SECTORS.
                        ;
  F008                  MCONIN	EQU	MONITOR+2*4	;CONSOLE IN
  F00C                  MCONOUT	EQU	MONITOR+3*4	;CONSOLE OUT
  F010                  MSELDSK	EQU	MONITOR+4*4	;SET CURRENT LOGGED DRIVE
  F01C                  MRDREC	EQU	MONITOR+7*4	;READ A STANDARD RECOR0D
  F020                  MWRREC	EQU	MONITOR+8*4	;WRITE A STANDARD RECORD
  F014                  MRECAL	EQU	MONITOR+5*4
  F018                  MSEEK	EQU	MONITOR+6*4
  F024                  MRDID	EQU	MONITOR+9*4
  F028                  MWBOOT	EQU	MONITOR+10*4		;WARM BOOT
                        ;
                        ;************************************************************************************************************
                        ;
                        ;	FCB EQUATES
                        ;
                        ;	THE FCB CONSISTS OF 36 BYTES OF DATA:
                        ;	ONLY BYTES 0 TO 31 ARE AN EXACT COPY OF THE DIRECTORY ENTRY
                        ;
                        ;	   
                        ;	   BYTES	FUNCTION
                        ;	   -----        --------
                        ;	   0 -7	FILENAME
                        ;	   8 -10 	FILENAME EXTENSION
                        ;	   11	FTY  - FILE TYPE
                        ;	   12-13	FSB  - FILE'S STARTING BLOCK
                        ;	   14-15 	FSZ  - FILE SIZE IN RECORDS (A RECORD IS EQUIVALENT TO A SECTOR)
                        ;	   16-17 	FLA  - FILE LOAD ADDRESS - USED TO DETERMINE WHERE FILE WILL LOAD
                        ;	   18-19	FSZBH - FILE SIZE IN BYTES HIGH WORD
                        ;	   20-21	LRBL - THIS LAST RECORD BYTE LENGTH OR NUMBER OF BYTES IN THE LAST RECORD
                        ;		SO ACTUAL FILE SIZE IN BYTES IS 512*FSZ - (512 - FSZBL)
                        ;	   22-23 	SPARE COULD MAKE THIS DATE
                        ;	   24-25	CBN  - FILE'S CURRENT BLOCK NUMBER
                        ;	   26-27	CRN  - CURRENT RECORD NUMBER - DATA BEGINS AT CRN=1.  CRN=O is the MODULE LOAD TABLE
                        ;	   28-29	RELB - RELATIVE BLOCK NUMBER
                        ;	   30-31 	RELR - RELATIVE RECORD NUMBER FILE WILL LOAD.
                        ;
                        ;	-----------------32 to 36 ARE TRANSIENT VALLUES AND NOT IN THE DIRECTORY------------------
                        ;	   .
                        ;	   32	CMLTI - THIS IS THE CURRENT MODULE LOAD INDEX.  JUST ONE BYTE I.E UP TO 256 MODULES
                        ;	   33	NMSECT - MODULE SIZE IN SECTORS. THIS IS THE NUMBER OF RECORDS IN THE PARTICULAR MODULE;
                        ;		WHICH IN POINTED TO MY CMLTI
                        ;	   34	MEMORY PAGE TO LOAD
                        ;	   34 	DRIVE
                        ;	   35 	LBUFCNT - NUMBER BYTES IN LAST BUFFER.  ALLOWS TO MANAGE BINARY FILES SO CPMEOF IS NOT NEEDED
                        ;
                        ;	THE LBA VALUES SEQUENTIALLY GO FROM 0, 2, 4 ETC BECAUSE WE ARE READING BYTES BACK FROM THE DRIVE
                        ;	RATHER THAN 16 BITS , SO TWO 256 READS (2 LBAs) WILL EQUAL 512 BYTES WHICH IS THE NOMINAL BYTES PER SECTOR
                        ;	DISC STRUCTUR.  EACH SECTOR READ WILL READ IN 2 SECTORS
                        ;	[LBA0][LBA2][LBA4][LBA6][LBA8][LBA10][LBA12][LBA14]<-------FILES BEGIN AT BLOCK 2
                        ;	[BOOT][BAT1][BAT2][BAT3][DIR1][DIR2 ][DIR3 ][DIR4 ][REC1BLK2,REC2BLK2,RECS3BLK2,REC4BLK2][REC1BLCK3...ETC]
                        ;	<-------BLOCK 0--------><--------BLOCK 1----------><-----------BLOCK 2------------------>
                        ;
                        ;	EACH BLOCK IS 4 SECTORS OR or 4 x 512 = 2048 Bytes - we can call see the similarity of blocks to pages
                        ;
                        ;	BLOCK ALLOCATION TABLE [BAT] SECTORS ARE INITIALISED TO 0, THUS AVAILABLE BLOCKS ARE INDICATED BY THE VALUE OF 0000H.
                        ;	WITH THE LAST AVAILABLE BLOCK BEING SET TO -1 IN THE LAST BAT PAGE.
                        ;	ALLOCATED BLOCKS HAVE A NON ZERO BLOCK NUMBER POINTING TO THE NEXT BLOCK IN THE LINK AND THE FINAL BLOCK
                        ;	IN THE LINK INDICATED BY A BLOCK NUMBER VALUE OF FF80H WHICH IS A SIMPLE INVERSION OF THE FIRST 9 BITS
                        ;	WHICH ARE UNUSED.
                        ;
                        ;	FOR EXAMPLE, BAT 1 WOULD LOOK LIKE THIS
                        ;
                        ;	BAT 1
                        ;	BLOCK NUMBER	VALUE	COMMENT
                        ;
                        ;	[ 0	FF80   ]	BOOT SECTOR, PLUS BATs OCCUPY A SINGLE BLOCK (BLOCK 0)
                        ;	[ 1	FF80   ]	DIRECTORY SECTORS OCCUPY A SINGLE BLOCK (BLOCK 1)
                        ;	[ 2	0003   ]	POINTS TO NEXT BLOCK IN LINK.  FILE IS SHELL.SYS (2 BLOCKS IN SIZE)
                        ;	[ 3	FF80   ]	LAST BLOCK IN THE FILE
                        ;	[ 4	0005   ]	POINTS TO NEXT BLOCK IN LINK.  FILE IS BDOS.SYS (2 BLOCKS IN SIZE)
                        ;	[ 5	FF80   ]	LAST BLOCK IN THE LINK
                        ;	[ 6	0007   ]	TEST FILE 3 BLOCKS LONG
                        ;	[ 7	0008   ]	2ND BLOCK
                        ;	[ 8	FF80   ]	LAST BLOCK IN FILE
                        ;	[ 9	0000   ]
                        ;	[ 9	0000   ]
                        ;		ETC
                        ;
                        ;	FOR THIS REASON THE FCB MUST CONTAIN THE FILE STARTING BLOCK (FSB) SO THE START  OF THE LINK
                        ; 	CAN BE FOUND.
                        ;
                        ;	BAT SECTORS ARE ORGANSIED AS FOLLOWS:
                        ;
                        ;	BAT SECTOR 1[BLK0,BLK1,BLK2,BLK3.......BLK255]
                        ;	BAT SECTOR 2[BLK256,BLK257,BLK258,.....BLK511]
                        ;	BAT SECTOR 2[BLK512,BLK513,BLK514..... BLK719,-1]
                        ;
                        ;
                        ;	NOTE:  CPM/TDOS OPERATES AT THE RECORD LEVEL SO THE TASK OF TDOS IS TO BE ABLE TO
                        ;	MAP BETWEEN FILE RECORDS LOCATION WITHIN A BLOCK ON THE DISC TRACK AND SECTOR NUMBER
                        ;
                        ;	BAT SECTORS ARE ORGANSISED AS 3 BAT PAGES/SECTOR
                        ;	[PAGE3][PAGE2][PAGE1][ 0 0 0 0 0 0 0 0].
                        ;	SO THE LSB 8 BITS REPRESENT THE ACTUAL BLOCK NUMBER AND THE NEXT 3 BITS THE BAT PAGE NUMBERS
                        ;	BAT 0 = 000, BAT 1 = 001, BAT 2 = 010 AND BAT 3 = 011.
                        ;
                        ;	SO SHIFTING THE BLOCK NUMBER BY 8  SHIFT COUNT AND APPLYING THE MASK 00FFH YIELDS THE PAGE NUMBER
                        ;	TO WHICH THE BLOCK NUMBER BELONGS.
                        ;
                        ;**********************************************************************************************************************
                        ;
  0000                  NAM	EQU	0	
  000B                  FTY	EQU	11		;TYPE 
  0010                  FLA	EQU	16		;FILES LOAD ADDRESS
  001A                  CRN	EQU	26	 	;NEXT RECORD TO READ/WRITE 
  0018                  CBN	EQU	24	 	;CURRENT BLOCK NUMBER
  001C                  RELB	EQU	28		;RANDOM ACCESS RELATIVE BLOCK NUMBER
  001E                  RELR	EQU	30		;RELATIVE RECORD NUMBER
  000C                  FSB	EQU	12		;FILE STARTING BLOCK
  000E                  FSZ	EQU	14		;FILE SIZE IN SECTORS
  0014                  LRBL	EQU	20		;NUMBER OF BYTES IN THE LAST RECORD
  0020                  CMLTI	EQU	32		;CURRENT MLINDEX - 0 REFERS TO MAIN MODULE
  0021                  NMSECT	EQU	33		;NUMBER OF SECTORS/RECORDS IN THE PARTICULAR MODULE
  0022                  MPAGE	EQU	34
                        ;
                        ; MEDIA TYPE 00FDH FLOPPY DISC HAS BEEN DEPRECATED
                        ;
                        ;TRKDSK	EQU	80		;TRACKS PER DISK
  0012                  SECTRK	EQU	18		;SECTORS PER TRACK
  0200                  BYTSEC	EQU	512		;BYTES PER SECTOR
  0004                  SECBLK	EQU	4		;SECTOR PER BLOCK THIS MEANS THERE ARE 2 BAT SECTORS
                        				; 80*18*2/SECBLK = 720 IE 2*512 SECTORS REQUIRED
  0001                  LBASECT	EQU	1		;NUMBER OF LBAS PER SECTOR (DUE TO 256 BYTE READS)
  0001                  RSVDSEC	EQU	1		;RESERVED SECTORS FOR BOOT SECTOR
  0002                  NSIDES	EQU	2		;NUMBER OF SIDES
                        ;SECDSK	EQU	NSIDES*SECTRK*TRKDSK	;SECTORS ON DISK
  0001                  NBATS	EQU	1		;NO OF BAT ENTRIES ie backup etc
  0004                  NDSECT	EQU	4		;NO OF DIRECTORY SECTORS PER DISK
  0002                  FBATSEC 	EQU	RSVDSEC+1		;FIRST BAT SECTOR  OFFSET FROM 0
  0004                  FDIRRN	EQU	4		;FIRST DIRECTORY RECORD NUMBER ()
  0000                  DIRTRK	EQU	0		;DIRECTORY STARTS HERE
  0000                  BATTRK	EQU	0
  0008                  BATSF	EQU	8		;DETERMINES THE BAT PAGE (SEE EXPLANATION ABOVE)
                        ;BATMSK	EQU	01FFH		;BASED ON BYTSEC/2 ENTRIES PER BAT PAGE - USED IN GETBATP
                        ;BATMSK SHOULD BE 00FF
  00FF                  BATMSK	EQU	0FFH		;BASED ON BYTSEC/2 ENTRIES PER BAT PAGE - USED IN GETBATP
  FF80                  LASTBLK	EQU	0FF80H		;INDICATES LAST BLOCK IN A FILE
  0200                  BUFSIZ	EQU	BYTSEC		;DISK BUFFER SIZE
                        ;
  000B                  NAMSIZ	EQU	11		;FILENAME SIZE IN BYTES
  0012                  NAMEOFF2	EQU	18		;2ND NAME OFFSET INTO FCB
  0020                  DIRSIZ	EQU	32		;NO. OF BYTES PER ENTRY
  0001                  RDCMD	EQU	1	 	;READ COMMAND
  0002                  WRCMD	EQU	2	 	;WRITE COMMAND
                        
  FFFF                  MINUS1	EQU	-1		;USED FOR GENERAL ERROR
  D164   3F             WILD	BYTE	'?'
  D165   FF             ALLONES	BYTE	-1		;;USED FOR GENERAL ERROR
  D166                  	EVEN
                        ;
  D166   0000           DISK	WORD	0		;CURRENTLY SELECTED DISK LS BYTE USED
  D168   0000           CAB	WORD	0	 	;CURRENTLY ALLOCATED BLOCK NUMBER
  D16A   0000           CBP   	WORD	0		;CURRENT BAT LOCATION POINTER
  D16C   0000           CBO	WORD	0		;CURRENT OFFSET INTO BLOCK
  D16E   FFFF           CBSECT	WORD	-1		;CURRENT BAT SECTOR IN MEMORY
  D170   0000           DIRENT	WORD	0		;USED IN DIRECTORY SEARCH
  D172   D83E           WRADDR	WORD	DIRBUFF		;CURRENT DMA ADDRESS
  D174   0000           DMAADDR	WORD	0		;CURRENT DMA ADDRESS FOR MONITOR
                        ;TRACK	WORD	0
                        ;SECTOR	WORD	0
  D176   0000 0000      LBA	WORD	0,0		;BOTH THIS AND SECTOR ARE PROBABLY NO NEEDED ANYMORE
  D17A   0000           CDSECT	WORD	0	 	;CURRENT DIRECTORY SECTOR
  D17C   0000           CCMD	WORD	0	 	;CURRENT COMMAND
  D17E                  	EVEN
                        ;
                        ; LBA CONSTANTS
                        ;
  0000                  BOOT_LBA	EQU	0
  0002                  BAT_LBA	EQU	2
  0008                  DIR_LBA	EQU	8
  0010                  FINAL_LBA	EQU	16
  0012                  BLK2_LBA	EQU	18
                        
                        ;
                        ;******************************
                        ;
                        ;	WARM BOOT INTERCEPT
                        ;
                        ;*******************************
                        ;
  D17E   2DC0           BDOS0	RET
  D180   04C0           	CLR	R0			;CLEAR CHANGE AND WRITE FLAGS IN BM
  D182   04E0 D63A      	CLR	@BATCHG			;ZERO CAUSES A BATTO BE READ IN
  D186   0460 F028      	B	@MWBOOT			;CALL MONITOR
                        ;
                        ;*******************************
                        ;
                        ;	CONSOLE OUTPUT
                        ;	CHAR IN R3 LSB 
                        ;
                        ;********************************
                        ;
                        ;
  D18A   06C3           COUT	SWPB	R3			;MOVE CHAR TO UPPER MSB FOR MCONOUT
  D18C   D083           	MOVB	R3,R2	 		;CHAR IN MSB OF R2
  D18E   2DA0 F00C      	CALL	@MCONOUT
  D192   2DC0           	RET	
                        ;
                        ;********************************
                        ;
                        ;	CONSOLE INPUT INTO LSB OF R1
                        ;	NOTE ALL OTHER SYSTEMS USE MSB
                        ;
                        ;********************************
                        ;
                        CIN	;MOV	@MON_PTR,R0		;MONITOR ADDRESS
                        	;AI	R0, MCONIN			;ADD THE OFFSET INTO THE MONITOR
  D194   2DA0 F008      	CALL	@MCONIN		;(R0)			;INPUT CHAR IN R1
  D198   06C1           	SWPB	R1
  D19A   2DC0           	RET				;RETURN CHAR IN MSB OF R1
                        ;
                        ;-----------------------------------
                        ;
                        ;  DIRECT CONSOLE IO - BYPASS ANY CHARACTER
                        ;  CHECKING.
                        ;
                        ;  IF R3 = FF00H THEN INPUT A CHAR
                        ;  IF R3 = IS LESS THAN 00FFH THEN OUTPUT THE CHAR IN MSB
                        ;
                        ;-----------------------------------------------------
                        ;
  D19C   D020 D165      DCONIO	MOVB	@ALLONES,R0
  D1A0   9003           	CB	R3,R0
  D1A2   13F8           	JEQ	CIN
  D1A4   10F2           	JMP	COUT
                        ;
                        ;*************************
                        ;
                        ;	SELECT A DISK
                        ;
                        ;*************************
                        ;
  D1A6   C083           DSKFUN	MOV	R3,R2	 		;FOR MONITOR
  D1A8   C803 D166      	MOV	R3,@DISK
  D1AC   0460 F010      	B	@MSELDSK
                        
                        ;
                        ;*************************
                        ;
                        ;	GET CURRENT DISK
                        ;	RETURN IN MSB OF R1
                        ;
                        ;*************************
                        ;
  D1B0   C060 D166      CDFUNC	MOV	@DISK,R1	 		;FOR MONITOR
  D1B4   2DC0           	RET
                        ;
                        ;========================================================================
                        ;
                        ;	BDOS SET THE DMA ADDRESS
                        ;
                        ;=========================================================================
                        ;
                        DMAFUN
  D1B6   C803 D172      	MOV	R3,@WRADDR		;COPY FOR WRSEQ
  D1BA   C803 D174      	MOV	R3,@DMAADDR
  D1BE   2DC0           	RET
                        ;******************************
                        ;
                        ;	MONITOR SET THE DMA ADDRESS IN R2
                        ;
                        ;******************************
                        ;
  D1C0   C802 D174      _SETDMA	MOV	R2,@DMAADDR
  D1C4   2DC0           	RET
                        
                        ;
                        ;=============================================================================
                        ;
                        ; MLOAD - LOAD MODULES USING THE MODULE LOAD TABLE
                        ;
                        ; NOW LOAD THE PROGRAMME's MODULE LOAD TABLE (MLT) (FIRST SECTOR OF ALL NON SYSTEM FILES).
                        ; PROGRAMMES CAN BE MADE UP MULTIPLE MODULES ACROSS MORE THAN A SINGLE MEMORY SEGMENT.
                        ;
                        ;;;;;	CALL	@GETMLT		;LOAD THE FIRST RECORD WHICH IS THE MLT R1 IS CLEAR
                        ;
                        ;
                        ;===============================================================================:
                        ;
  D1C6   2DA0 D20C      MLOAD:	CALL	@GETMLT
                        ;
                        ; NOW LOAD THE FILE ACCORDING TO THE MODULE TABLE
                        ;
  D1CA   0203 D000      	LI	R3,0D000H		;RETURN FREE MEMORY OR LAST LOAD ADDRESS
  D1CE   2DC0           	RET
                        ;
                        ;--------------------------------------------------------------------------
                        ;
                        ;	OPEN A FILE (FUNCTION 15)
                        ;
                        ;	R3 -> FCB
                        ;
                        ;	THIS FUNCION TRANSFERS ALL THE FILE'S  DIRECTORY DATA
                        ;	TO THE FCB.  IF THE FILE IS NOT FOUND -1 IS RETURNED IN
                        ;	REGISTER R1. NOTE THAT THIS FUNCTION WILL NOT CREATE AN
                        ;	ENTRY IF ONE DOESN'T EXIST. 'MAKEFIL(FUNCTION 22) MUST
                        ;	FIRST BE CALLED, HOWEVER IF 'MAKEFIL' IS CALLED THEN
                        ;	OPEN DOES NOT NEED TO BE CALLED EXPLICITLY IN THIS 
                        ;	INSTANCE.
                        ;
                        ;
                        ;----------------------------------------------------------------------------
                        ;
  D1D0   C203           FOPEN:	MOV	R3,R8		;COPY FCB POINTER FOR INTERNAL USE
  D1D2   2DA0 D368      	CALL	@SEARCH1		;OPEN THE DIRECTORY - GET POINTER IN R3
  D1D6   C041           	MOV	R1,R1		;SUCCESSFUL OPEN ?
  D1D8   1117           	JLT	OPENE
  D1DA   C048           	MOV	R8,R1
  D1DC   C083           	MOV	R3,R2		;DONT TOUCH DIRECTORY POINTER
  D1DE   0221 000B      	AI	R1,NAMSIZ 		;POINT TO FDE
  D1E2   0222 000B      	AI	R2,NAMSIZ		;R2 -> DIRECTORY ENTRY
  D1E6   0200 0015      	LI	R0,DIRSIZ-NAMSIZ	;NO OF BYTES TO TRANSFER
  D1EA   DC72           OPENA:	MOVB	*R2+,*R1+		;TRANSFER ENTRIES
  D1EC   0600           	DEC	R0
  D1EE   16FD           	JNE	OPENA
                        ;
                        ;  'MAKFIL' ENTERS HERE ALSO;
                        ;
                        
  D1F0   04C1           OPENENT:	CLR	R1
  D1F2   CA01 0018       	MOV	R1,@CBN(R8)		;ZERO CURRENT BLOCK FIELD
  D1F6   CA01 001E      	MOV	R1,@RELR(R8)
  D1FA   CA01 001C      	MOV	R1,@RELB(R8)
  D1FE   CA01 0014      	MOV	R1,@LRBL(R8)
  D202   CA01 001A      	MOV	R1,@CRN(R8)
                        ;	SETO	@MLBUF		;INVALIDATE MLBUF SO IT IS NOT REUSED FROM A PREVIOUS OPEN
  D206   2DC0           	RET
                        
  D208   0701           OPENE:	SETO	R1
  D20A   2DC0           	RET
                        
                        ;=================================================================================
                        ;
                        ;FOR VERSION 4, WE LOAD THE FIRST 512 BYTES INTO MLBUF TO MANAGE THE
                        ;LOCATION TABLE.   THE LOCATION TABLE IS 128 * 4 BYTES LONG OR 512
                        ;THEREFORE THE SECOND SECTOR IS THE FIRST FILE SECTOR.  THE FILE SYSTEM
                        ;DOES NOT NEED TO KNOW ABOUT THIS AS IT JUST MEANS THAT EACH FILE IS 512 BYTES LONGER
                        ;
                        ;ALL FILES, EXCEPT THE SYSTEM FILES HAVE THIS FORMAT.  IT MEANS THAT WHEN A FILE IS CREATED
                        ;AN EMPTY MODULE LOCATION TABLE SECTOR WILL BE ZEROED AND WILL BE THE FIRST SECTOR
                        ;WHICH MEANS THAT IF IT IS ZERO IT IS TREATED AS A NORMAL TPA/LADDR FILE LOAD/SEQUENTIAL READ.
                        ;
                        ;
                        ;CMLTI      NUMBER OF SECTORS   LOAD ADDRESS
                        ;[ 8 bits | ( NMSECT 8 bits)][     16 bits       ]
                        ;[SEG     |   Nx512 sectors ][LOAD ADDRESS OFFSET]
                        ;  0	   12	0X500H
                        ;  1	...etc
                        ;  FF	FF	FFFF	; END OF TABLE
                        ;
                        ;SO BEGIN LOADING AT THE FIRST INDEX.
                        ;THE NEXT INDEX WILL BE USED ONCE THE CRN - NMSECT
                        ;=================================================================================
                        ;
                        ;
                        ; LOAD AND INITIALISE THE LOCATION TABLE INTO MBUF.
                        ; ASSUME R8 HOLDS FCB
                        ;
                        ; CMLTI - THIS IS THE CURRENT MODULE LOAD INDEX.  JUST ONE BYTE I.E UP TO 256 MODULES
                        ; MODS - MODULE SIZE.  THIS IS THE NUMBER OF 512 BYTE RECORDS IN THE PARTICULAR MODULE;
                        ;
                        ; WHICH IN POINTED TO MY CMLTI
                        ;
                        ;
  D20C   04C0           GETMLT:	CLR	R0
  D20E   DA00 0020      	MOVB	R0,@CMLTI(R8)		;SET CLMTI TO ZERO
  D212   0203 DA3E      	LI	R3,MLBUF
  D216   C803 D174      	MOV	R3,@DMAADDR		;SET DMA ADDRESS FOR MLBUF
  D21A   C0C8           	MOV	R8,R3		;NEED THE FCB IN R3
  D21C   2DA0 D2EE      	CALL	@RDSEQ		;RDSEQ INCREMENTS CRN
                        ;
                        ; NOTE:  IF THE MLI IS ZERO, THAT IS, DEFAULT, THEN SETTING THE PARAMETERS BELOW WILL HAVE NO IMPACT
                        ;
  D220   0201 DA3E      	LI	R1,MLBUF		;POINT TO THE MODULE INDEX BUFFER
  D224   DA31 0022      	MOVB	*R1+,@MPAGE(R8)		;THIS IS MEMORY PAGE
  D228   DA31 0021      	MOVB	*R1+,@NMSECT(R8)	;NUMBER OF RECORDS IN THIS MODULE
  D22C   CA11 0010      	MOV	*R1,@FLA(R8)		;FLA OF ZERO IS DEFAULT. THIS IS THE LOAD ADDRESS FOR THE MODULE
  D230   04C1           	CLR	R1
  D232   2DC0           	RET
                        
                        ;
                        ; WE NEED TO ZERO IT AS THIS IS THE DEFAULT FOR A SINGLE MODULE
                        ;
  D234   04C0           MAKEMLT:	CLR	R0
  D236   DA00 0020      	MOVB	R0,@CMLTI(R8)		;SET CLMTI TO ZERO
  D23A   0220 0200      	AI	R0, BYTSEC
  D23E   0201 DA3E      	LI	R1,MLBUF
  D242   04F1           MMLTA	CLR	*R1+		;PAGE = 0, NUMBER OF SECTORS = 0, STARTING ADDRESS = 0
  D244   0600           	DEC	R0
  D246   16FD           	JNE	MMLTA
                        ;
  D248   0200 DA3E      	LI	R0,MLBUF
  D24C   C800 D174      	MOV	R0,@DMAADDR		;SET DMA ADDRESS FOR MLBUF
  D250   C0C8           	MOV	R8,R3		;NEED THE FCB IN R3
  D252   2DA0 D28A      	CALL	@WRSEQ		;RDSEQ INCREMENTS CRN ETC
  D256   2DC0           	RET
                        ;
                        ;
                        ;***************************************************************************
                        ;
                        ;	CLOSE A	FILE (FUNCTION 16)
                        ;
                        ;	R3 -> FCB
                        ;
                        ;	SIMILAR TO OPEN FUNCTION EXCEPT THAT THE FILE SHOULD 
                        ;	HAVE BEEN PREVIOUSLY EITHER OPENED USING 'OPEN' OR
                        ;	CREATED USING 'MAKFIL'. ANY OTHER METHOD OF CALLING
                        ;	WILL TRANSFER JUNK TO THE DIRECTORY - NOT A PLEASANT 
                        ;	THOUGHT.
                        ;
                        ;	CLOSE ALSO ZERO'S THE CRN & CBN WORDS SO THAT OPEN DOES
                        ;	NOT HAVE TO INITIALISE THESE TWO VALUES.
                        ;
                        ;*****************************************************************************
                        ;
  D258   4643 4C4F      DB_FCLOSE:	TEXT	"FCLOSE"
  D25C   5345           
  D25E   00             	BYTE	0
  D25F   00             	EVEN
                        
  D260   C203           FCLOSE:	MOV	R3,R8		;COPY FCB POINTER
  D262   2DA0 D368      	CALL	@SEARCH1 		;MAKE SURE THE FILE EXISTS AND OPEN THE DIRECTORY
  D266   C041           	MOV	R1,R1	 	;ERROR ?
  D268   110F           	JLT	CLOSEB	 	;YES
  D26A   C048           	MOV	R8,R1		;FCB POINTER
  D26C   C083           	MOV	R3,R2		;DONT TOUCH R3
  D26E   0221 000B      	AI	R1,NAMSIZ		;ENTRY DATA POINTER
  D272   0222 000B      	AI	R2,NAMSIZ		;DIR ENTRY POINTER
  D276   0200 0015      	LI	R0,DIRSIZ-NAMSIZ		
  D27A   DCB1           FCLOSE1:	MOVB	*R1+,*R2+		;UPDATE DIRECTORY ENTRY
  D27C   0600           	DEC	R0
  D27E   16FD           	JNE	FCLOSE1
                        ;	
                        ; UPDATE DIRECTORY ENTRY
                        ;
                        ;	DEBUG	@DB_FCLOSE
                        ;	BLWP	@MONITOR
                        
                        ;	CALL	@WRREC	 	;ALL POINTERS ARE UNTOUCHED FROM SEARCH1
  D280   2DA0 D618      	CALL	@WRDIR		;UPDATE THE DIRECTORY ENTRY
  D284   2DA0 D480      	CALL	@RECLAIM		;TRY TO RECLAIM UNUSED BLOCKS	
  D288   2DC0           CLOSEB	RET
                        ;
                        ;***************************************************
                        ;
                        ;	WRITE SEQUENTIALLY (FUNCTION 21)
                        ;	CALL TO SETDMA BEFORE CALLING THIS FUNCTION
                        ;	R3 -> FCB
                        ;
                        ;	THIS FUNCTION IS CONTROLLED MAINLY BY 
                        ;	THE CRN (NEXT RECORD TO READ) COUNTER.
                        ;
                        ;	FOR VERSION 4 AND THE INTRODUCTION OF MODULES BDOS NEEDS TO FIRST
                        ;	CREATE THE MODULE LOAD HEADER IF THIS THE FIRST WRITE TO AN OPEN FILE.
                        ;
                        ;
                        ;
                        ;*****************************************************
                        ;
                        
  D28A   C203           WRSEQ:	MOV	R3,R8		;SAVE FCB POINTER
  D28C   2DA0 D51A      	CALL	@CRNTBC	 	;CRN TO RELATIVE BLOCK & REMAINDER
  D290   C803 D16C      	MOV	R3,@CBO		;SAVE OFFSET
                        ;
                        ;	IF WE COULD TRACE FROM EXISTING POSITION WE COULD SPEED THINGS UP AND STOP THRASHING
                        ;	TRACE1 WILL USE CRN
                        ;
  D294   C0C2           	MOV	R2,R3		;R3 NOW HOLDS RELATIVE BLOCK NUMBER
  D296   2DA0 D56C      	CALL	@TRACE
  D29A   8081           	C	R1,R2		;IF ALLOCATED CONTINUE
  D29C   1316           	JEQ	WRSEQ0
                        ;
                        ;	AT THIS POINT WE HAVE THE CBP FROM TRACE
                        ;	NXTBLK WILL FIND A BLOCK AND ALLOCATE IT (LINK) 
                        ;	BASED ON CBP
                        ;
  D29E   2DA0 D528      	CALL	@NXTBLK	 	;LOCATE A BLOCK AND RETURN IN R7
  D2A2   C041           	MOV	R1,R1		;ANY BLOCKS LEFT ?
  D2A4   1123           	JLT	WRSEQ2		;NO - SHOW ERROR
                        ;
                        ;	IN CASE WE CROSS BAT BOUNDARIES WE NEED TO ALLOCATE LAST BLOCK FIRST
                        ;	AND THEN POSTFIX THE CAB FOUND IN TRACE.  TRACE HAS FILLED THE CBP AND
                        ;	CAB WHICH NEED TO BE UPDATED. R7 IS THE CURRENT BLOCK POINTER AND
                        ;	R6 CONTAINS THE FREE BLOCK NUMBER
                        ;
  D2A6   0201 FF80      	LI	R1,LASTBLK		;ALLOCATE THIS BLOCK TO THIS FILE
  D2AA   C5C1           	MOV	R1,*R7		;NEW END OF LINK IN CURRENT BAT FROM NXTBLK
  D2AC   C807 D16A      	MOV	R7,@CBP		;AND KEEP CBP UPDATED
  D2B0   0720 D63A      	SETO	@BATCHG		;FORCE AN UPDATE TO THE BAT
                        ;
                        ;	NOW UPDATE PREVIOUS LAST BLOCK TO POINT NOW TO THE NEW LAST BLOCK
                        ;
  D2B4   2E06           	PUSH	R6		;PUSH NEW ALLOCATED BLOCK CAB
  D2B6   C0E0 D168      	MOV	@CAB,R3		;GET PREVIOUS LAST BLOCK RETURNED FROM TRACE
  D2BA   2DA0 D598      	CALL	@GETBATP		;FIND THE BAT AND GET THE POINTER FROM THE INDEX
  D2BE   2E46           	POP	R6
  D2C0   C5C6           	MOV	R6,*R7		;UPDATE TO NEW END OF LINK
  D2C2   C806 D168      	MOV	R6,@CAB		;UPDATED FROM NXTBLK
  D2C6   0720 D63A      	SETO	@BATCHG		;FORCE AN UPDATE TO THE BAT
                        ;	
  D2CA   C0A0 D168      WRSEQ0	MOV	@CAB,R2		;RECOVER DISK BLOCK
  D2CE   C0E0 D16C      	MOV	@CBO,R3		;AND OFFSET
  D2D2   0200 0002      	LI	R0,WRCMD
  D2D6   C800 D17C      	MOV	R0,@CCMD		;CURRENT COMMAND
                        
  D2DA   2DA0 D348      	CALL	@RWREC
  D2DE   C041           	MOV	R1,R1		;WAS THERE AN ERROR
  D2E0   1105           	JLT	WRSEQ2		;JUMP IF YES
                        
  D2E2   05A8 000E      	INC	@FSZ(R8) 		;BUMP THE SECTOR COUNT
  D2E6   05A8 001A      	INC	@CRN(R8) 		;BUMP CURRENT RECORD
                        
  D2EA   04C1           WRSEQ1	CLR	R1
  D2EC   2DC0           WRSEQ2	RET
                        
                        ;
                        ;=====================================================================================
                        ;	READ SEQUENTIALLY
                        ;	R3 -> FCB
                        ;	ASSUME THE CALL TO DMAFUNC HAS BEEN MADE SO WE CAN
                        ;	SAFELY SET THE PAGE INDEX IF NECESSARY USING FCB IN R3
                        ;
                        ;=================================================================================
                        ;
  D2EE   C203           RDSEQ:	MOV	R3,R8		;COPY FCB ADDRESS OF FCB
  D2F0   8A28 001A      	C	@CRN(R8),@FSZ(R8)	;END OF FILE ?
  D2F4   000E           
  D2F6   1414           	JHE	RDSEQ1		;YES
  D2F8   2DA0 D51A      	CALL	@CRNTBC		;CONVERT CRN TO A RELATIVE BLOCK NUMBER
  D2FC   C803 D16C      	MOV	R3,@CBO		;SAVE OFFSET AND USE BLOCK IN R2 TO
  D300   2DA0 D56C      	CALL	@TRACE		;TRACE THROUGH THE LINKED ALLOCATION LIST
  D304   C0E0 D16C      	MOV	@CBO,R3		;RECOVER VARIABLES FOR RWREC
  D308   C0A0 D168      	MOV	@CAB,R2
  D30C   0200 0001      	LI	R0,RDCMD
  D310   C800 D17C      	MOV	R0,@CCMD		;CURRENT COMMAND
                        ;
                        ; R8 HOLDS FCB
                        ;
  D314   2DA0 D348      	CALL	@RWREC
  D318   05A8 001A      	INC	@CRN(R8)		;BUMP TO NEXT RECORD 
  D31C   04C1           	CLR	R1
  D31E   2DC0           	RET
                        ;
  D320   0701           RDSEQ1	SETO	R1
  D322   2DC0           	RET
                        ;
                        ;*******************************
                        ;
                        ;	R3 -> FCB
                        ;	READ RANDOM RECORD
                        ;
                        ;********************************
                        ;
  D324   C8E3 001C      RDRND:	MOV	@RELB(R3),@CBN(R3)	;TRANSER RECORD NUMBER
  D328   0018           
  D32A   C8E3 001E      	MOV	@RELR(R3),@CRN(R3)
  D32E   001A           
  D330   2DA0 D2EE      	CALL	@RDSEQ
  D334   0628 001A      	DEC	@CRN(R8)		;READ RANDOM CAN'T INCREMENT THE CRN
  D338   2DC0           	RET
                        ;
                        ;*******************************
                        ;
                        ;	WRITE RANDOM RECORD
                        ;	R3 -> FCB
                        ;	(R3)RELR  MUST HOLD THE RECORD TO WRITE TO
                        ;
                        ;*******************************
                        ;
  D33A   C8E3 001C      WRRND:	MOV	@RELB(R3),@CBN(R3)	;TRANSEFER RECORD NUMBER
  D33E   0018           
  D340   C8E3 001E      	MOV	@RELR(R3),@CRN(R3)
  D344   001A           
  D346   10A1           	JMP	WRSEQ		;NORMAL SEQUENTIAL WRITE
                        ;
                        ;*******************************
                        ;
                        ;	COMMON READ WRITE ENTRY
                        ;
                        ;	R8 --> FCB
                        ;	R2 = CURRENT BLOCK NUMBER (ID)
                        ;	R3 = CURRENT BLOCK OFFSET
                        ;*******************************
                        ;
                        ;DB_RWREC	TEXT	"RWREC"
                        ;	BYTE	0
                        ;	EVEN
  D348   0A22           RWREC:	SLA	R2,2		;THERE ARE 4 SECTORS PER BLOCK
  D34A   A0C2           	A	R2,R3		;WE NOW HAVE THE BASE LBA
  D34C   0A13           	SLA	R3,1		;BECAUSE WE HAVE TO READ TWO LBA FOR AN EFFECTIVE 512 BYTES
  D34E   C0A0 D172      	MOV	@WRADDR,R2		;THIS IS THE LOCAL COPY OF DMA ADDR
  D352   2DA0 D1C0      	CALL	@_SETDMA		;CAUGHT WITH CALLS THROUGH DMAFUN VALUE IN R4 FOR MONITOR
  D356   C020 D17C      	MOV	@CCMD,R0		;GET TYPE
  D35A   0280 0002      	CI	R0,WRCMD		;READ ? 
                        ;	DEBUG	@DB_RWREC
  D35E   1602           	JNE	RWREC_R	 	;TRY FOR WRITE
  D360   0460 D55A      	B	@WRREC	 	;RETURN FROM RDREC
  D364   0460 D548      RWREC_R:	B	@RDREC	 	;ASSSUME READ
                        ;
                        ;
                        ;***************************************************************
                        ;
                        ;	SEARCH FIRST( LOOK FOR DIRECTORY ENTRY)
                        ;
                        ;	NORMAL DIRECTORY SEARCH BEGINNING AT THE
                        ;	START OF THE DIRECTORY CONTINUING TILL END.
                        ;
                        ;	E5 => DELETED ENTRY	
                        ;	00 => END OF DIRECTORY	
                        ;	R3 -> FCB	
                        ;
                        ;	RETURN 
                        ;		R1 =  MINUS ONE FOR BAD RESULT 
                        ;		R3 -> CURRENT DIRECTORY ENTRY
                        ;
                        ;***************************************************************
                        ;
  D368   C203           SEARCH1:	MOV	R3,R8		;SAVE FCB FOR DIROPN
  D36A   0720 D170      	SETO	@DIRENT		;SET CURRENT SECTOR DIRECTORY INDEX
  D36E   04E0 D17A      	CLR	@CDSECT		;BEGIN SEARCHING AT FIRST SECTOR
  D372   2DA0 D4C0      	CALL	@DIROPN	 	;OPEN THE DIRECTORY
  D376   1014           	JMP	DLOOK		;RETURN FROM DLOOK
                        ;
                        ;***************************************************************
                        ;
                        ;	SEARCH NEXT (SEARCH2)
                        ;
                        ;	SIMILAR TO CPM - BASICALLY CONTINUES
                        ;	WHERE LAST SEARCH LEFT OFF. THAT IS IT 
                        ;	SIMPLY DOES NOT ALTER THE VALUE OF THE 
                        ;	DIRENT AND CDSECT VARIABLES.
                        ;
                        ;**************************************************************
                        ;
  D378   C203           SEARCH2:	MOV	R3,R8
  D37A   2DA0 D4C0      	CALL	@DIROPN		;OPEN THE DIRECTORY
  D37E   1010           	JMP	DLOOK
                        ;
                        ;-------------------------------------------------
                        ;
                        ;  FUCTION 35 - GET FILE SIZE
                        ;
                        ;   R2 = FUNCTION NUMBER
                        ;   R3 -> FCB
                        ;
                        ;   PURPOSE - MOVE THE ADDRESS OF THE LAST RECORD
                        ;	      TO THE RELATIVE FIELDS
                        ;
                        ;-------------------------------------------------
                        ;
  D380   C203           GETSIZ:	MOV	R3,R8		;COPY FCB POINTER FOR INTERNAL USE
  D382   2DA0 D368      	CALL	@SEARCH1		;OPEN THE DIRECTORY
  D386   C041           	MOV	R1,R1		;SUCCESSFUL OPEN ?
  D388   1103           	JLT	GETSIZ1	
  D38A   CA28 000E      	MOV	@FSZ(R8),@RELR(R8)	;TRANSFER THE FILE SIZE
  D38E   001E           
  D390   2DC0           GETSIZ1:	RET
                        ;
                        ;--------------------------------------------------
                        ;
                        ;	FUCTION 36 - SET RELATIVE RECORD
                        ;	R2 =  FUNCTION NUMBER
                        ;	R3 -> FCB
                        ;
                        ;	PURPOSE - THE RELATIVE RECORD FIELD IS SET TO THE
                        ;	SAME FILE ADDRESS AS THE CURRENT BLOCK AND
                        ;	CURRENT RECORD.
                        ;
                        ;---------------------------------------------------
                        ;
  D392   C8E3 0018      SETREL:	MOV	@CBN(R3),@RELB(R3)	;TRANSFER RECORD POINTERS
  D396   001C           
  D398   C8E3 001A      	MOV	@CRN(R3),@RELR(R3)
  D39C   001E           
  D39E   2DC0           	RET
                        ;
                        ;*****************************************
                        ;
                        ;	GENERAL DIRECTORY SEARCH SUBROUTINE
                        ;	R8 = PTR TO FCB
                        ;	MUST CHECK FILE ATTRIBUTES FOR FILE TYPE
                        ;
                        ;******************************************
                        ;
  D3A0   2DA0 D4E2      DLOOK:	CALL	@DIRBLK	 	;GET NEXT ENTRY PNTR IN R3
  D3A4   1115           	JLT	NONTRY	 	;NOT FOUND
  D3A6   C083           DLOOK1	MOV	R3,R2	 	;SAVE PNTR
  D3A8   D012           	MOVB	*R2,R0	 	;TEST FOR EOD
  D3AA   11FA           	JLT	DLOOK	 	;DELETED ENTRY
  D3AC   1502           	JGT	DLOOK4	 	;VALID
  D3AE   04C3           	CLR	R3	 	;SHOW END OF DIRECTORY REACHED
  D3B0   100F           	JMP	NONTRY	
  D3B2   0200 000B      DLOOK4	LI	R0,NAMSIZ 		;NUMBER OF CHARS TO MATCH
  D3B6   C148           	MOV	R8,R5		;SAVE FCB PNTR
  D3B8   9815 D164      NXTLTR	CB	*R5,@WILD		;? WILL MATCH ALL (LIKE CPM)
  D3BC   1603           	JNE	DLOOK5		;PROCESS NORMALLY
  D3BE   0585           	INC	R5		;ELSE ASSUME MATCH SO BUMP POINTERS
  D3C0   0582           	INC	R2
  D3C2   1002           	JMP	DLOOK6
  D3C4   9D72           DLOOK5	CB	*R2+,*R5+		;MATCH ?
  D3C6   16EC           	JNE	DLOOK	 	;NO SO - KEEP LOOKING
  D3C8   0600           DLOOK6	DEC	R0	
  D3CA   16F6           	JNE	NXTLTR	 	;CONTINUE
  D3CC   04C1           	CLR	R1	 	;SHOW GOOD RESULT
  D3CE   2DC0           	RET	
  D3D0   0701           NONTRY	SETO	R1	 
  D3D2   2DC0           	RET			;SHOW NOT FOUND
                        ;
                        ;********************************	
                        ;
                        ;	CREATE A DIRECTORY ENTRY (FUNCTION 22)
                        ;
                        ;	ENTRY: 	R3 -> FCB
                        ;		R2 = 22
                        ;
                        ;	RETURN:	R1 = 0 EMPTY DIRECTORY FOUND
                        ;		R1 = FF NO EMPTY DIRECTORY AVAILABLE
                        ;
                        ;	THIS FUNCTION SHOULD BE CALLED ONLY WITH THE
                        ;	FILENAME IN THE FIRST 10 BYTES OF THE FCB. 'MAKFIL'
                        ;	MAKES A POINT OF ZEROING ALL BAR THE FILENAME WITH
                        ;	THE DIRECTORY ENTRY BEFORE WRITING IT TO DISK. HENCE
                        ;	YOU MUST CALL CLOSE TO PROPERLY TRANSFER ANY FILE 
                        ;	ATTRIBUTES ETC. ALSO NOTE THAT THE FSB WILL BE RETURNED
                        ;	HOWEVER ALL OTHER FCB ENTRIES WILL BE ZEROED.
                        ;
                        ;
                        ;******************************	
                        ;
                        ;IDE_MODIFICTION_IN PROGRESS
                        ;DB_MAKF1:	TEXT	"MAKFL1"	;TEMP FOR DEBUG
                        ;	WORD	0
                        ;	EVEN
                        
  D3D4   C203           MAKFIL:	MOV	R3,R8			;LOCAL FCB COPY
  D3D6   2DA0 D528      	CALL	@NXTBLK	 		;FIND A SECTOR FOR FSB AND PLACE IN CAB
  D3DA   C041           	MOV	R1,R1	 		;ERROR ?
  D3DC   112E           	JLT	MAKERR			;LOOKS LIKE DISK FULL 
  D3DE   C806 D168       	MOV	R6,@CAB			;UPDATE BLOCK NUMBER AND
  D3E2   C807 D16A      	MOV	R7,@CBP			;POINTER TO THE CURRENT BLOCK
                        
  D3E6   0720 D170      	SETO	@DIRENT			;SIMILAR TO SEARCH1
  D3EA   04E0 D17A      	CLR	@CDSECT			;MUST SET THESE VARIABLES
  D3EE   2DA0 D4C0      	CALL	@DIROPN	 		;OPEN THE DIRECTORY
  D3F2   2DA0 D4E2      NTHR	CALL	@DIRBLK	 		;GET ENTRY THROUGH R3
  D3F6   1121           	JLT	MAKERR			;END OF DIRECTORY
  D3F8   D013           	MOVB	*R3,R0	 		;CHECK ENTRY
  D3FA   15FB           	JGT	NTHR	 		;VALID ENTRY
                        ;
                        ; ASSUME R3 NOW POINTS TO DIR ENTRY AND R6 HOLDS THE LBA
                        ;
  D3FC   04C0           	CLR	R0
  D3FE   C148           	MOV	R8,R5		;R8 HOLDS THE FCB
  D400   0225 000B      	AI	R5,FTY		;FLUSH FROM FILE TYPE ENTRY
  D404   0202 0015      	LI	R2,DIRSIZ-NAMSIZ	;NUMBER OF BYTES TO ZERO
  D408   DD40           MKFIL2	MOVB	R0,*R5+
  D40A   0602           	DEC	R2
  D40C   16FD           	JNE	MKFIL2
  D40E   CA20 D168      	MOV	@CAB,@FSB(R8)		;TRANSFER FSB
  D412   000C           
  D414   0201 FF80      	LI	R1,LASTBLK		;MARK AS FIRST AND LAST BLOCK IN BAT
  D418   C020 D16A      	MOV	@CBP,R0
  D41C   C401           	MOV	R1,*R0		;SHOW ITS THE LAST BLOCK AS WELL AS THE FIRST
                        ;
                        ; NOW CREATE THE ZERO LENGTH FILE
                        ;
                        ;	MOV	R3,@DMAADDR
  D41E   0202 0020      	LI	R2,DIRSIZ		;TRANSFER FILENAME + FSB TO DIRECTORY
  D422   C148           	MOV	R8,R5	 	;SAVE FCB VECTOR
  D424   DCF5           MKFIL1	MOVB	*R5+,*R3+		;TRANSER FCB ENTRY TO DIRECTRY RECORD
  D426   0602           	DEC	R2
  D428   16FD           	JNE	MKFIL1
                        ;
                        ;
                        ; CALL WRDIR TO WRITE OUT THE DISC DIRECTORY ENTRY AND THEN UPDATE THE BAT;
                        ; R8 ->  FCB
                        ;
  D42A   2DA0 D618      	CALL	@WRDIR
  D42E   2DA0 D5F2      	CALL	@WRBAT	 	;UPDATE BAT AS DIRECTORY ENTRY IS VALID
  D432   C041           	MOV	R1,R1		;IF NO ERROR SIMULATE 'OPEN'
  D434   1102           	JLT	MAKERR
  D436   0460 D1F0      	B	@OPENENT
  D43A   0701           MAKERR	SETO	R1 
  D43C   2DC0           	RET
                        ;
                        ;*************************************************
                        ;
                        ;  RENAME A FILE
                        ;
                        ;  R3 -> FCB
                        ;  BYTES 0 - 17  OLD NAME
                        ;  BYTES 18- 27  NEW NAME
                        ;
                        ;*************************************************
                        ;
  D43E   C203           RENAME:	MOV	R3,R8
  D440   2DA0 D368      	CALL	@SEARCH1		;CHECK TO SEE IF THE FILE EXITS
  D444   C041           	MOV	R1,R1
  D446   110B           	JLT	RENAM2		;NOT FOUND
  D448   0200 000B      	LI	R0,NAMSIZ		;FILENAME SIZE	
  D44C   C083           	MOV	R3,R2		;R2 -> DIRECTORY ENTRY
  D44E   C048           	MOV	R8,R1
  D450   0221 0012      	AI	R1,NAMEOFF2		;POINT TO 2ND FILE NAME
  D454   DCB1           RENAM1	MOVB	*R1+,*R2+		;COPY NEW FILE NAME OVER OLD ONE
  D456   0600           	DEC	R0
  D458   16FD           	JNE	RENAM1		;JUMP IF NOT DONE
                        ;
                        ; NOW WRITE THE NEW DIRECTORY ENTRY BACK
                        ;
  D45A   2DA0 D618      	CALL	@WRDIR		;ALL DIRECTORY POINTERS UNTOUCHED FROM SEARCH1
  D45E   2DC0           RENAM2	RET
                        ;
                        ;******************************
                        ;
                        ;	ERASE A	DIRECTORY ENTRY
                        ;
                        ;	R3 -> FCB
                        ;
                        ;	ON RETURN R1 = 0 FOR DIRECTORY ENTRY FOUND
                        ;		     = -1 FOR NO DIRECTORY ENTRY FOUND
                        ;
                        ;*******************************
                        ;
  D460   C203           ERAFIL:	MOV	R3,R8
  D462   2DA0 D368      	CALL	@SEARCH1 		;LOOK FOR THE FILE ENTRY
  D466   C041           	MOV	R1,R1	 	;DID WE FIND IT ?
  D468   1129           	JLT	ERAERR	 	;NO
  D46A   0201 8000      	LI	R1,8000H		;R3->DIR ENTRY
  D46E   F8C1 0000      	SOCB	R1,@NAM(R3)		;MAKE DELETED
  D472   CA23 000C      	MOV	@FSB(R3),@FSB(R8)	;NB RECOVER BAT POINTER
  D476   000C           
  D478   04E8 000E      	CLR	@FSZ(R8)		;FORCE RE-ALLOCATION OF USED BLOCK
  D47C   2DA0 D618      	CALL	@WRDIR	 	;WRITE FDE BACK TO DISK
                        ;
                        ;---NOW RELEASE	ALLOCATED BLOCKS
                        ;
  D480   04C3           RECLAIM:	CLR	R3		;START AT FIRST BAT SECTOR
  D482   2DA0 D598      	CALL	@GETBATP 		;READ IN THE BAT TABLE
  D486   C0E8 000E      	MOV	@FSZ(R8),R3		;GET FILE SIZE FOR AND
  D48A   2DA0 D51E      	CALL	@RECTBC		;CONVERT FILE SIZE TO BLOCKS
  D48E   2DA0 D56C      	CALL	@TRACE		;TRACE THROUGH TO TO BLOCK NUMBER
  D492   0201 FF80      	LI	R1,LASTBLK
  D496   C0D7           	MOV	*R7,R3		;RECOVER BAT INDEX
  D498   C5C1           	MOV	R1,*R7		;ASSUME LAST LINK ENTRY
  D49A   C028 000E      	MOV	@FSZ(R8),R0		;ZERO FILE SIZE IE RECLAIM ALL BLOCKS?
  D49E   1601           	JNE	ERA00		;NO
  D4A0   04D7           	CLR	*R7		;YES SO ZERO LAST LINK
  D4A2   8043           ERA00	C	R3,R1		;LAST LINK ?
  D4A4   1307           	JEQ	ERA02		;YES
  D4A6   2DA0 D598      ERA01	CALL	@GETBATP		;GET INDEX (IN R5) TO NEXT BAT
  D4AA   C0D7           	MOV	*R7,R3 		;NEXT INDEX VALUE
  D4AC   04D7           	CLR	*R7		;ZERO TO SHOW BLOCK IS FREE
  D4AE   8043           	C	R3,R1		;CHECK FOR FINAL LINK
  D4B0   1301           	JEQ	ERA02		;YES - SO WE'RE FINISHED
  D4B2   10F9           	JMP	ERA01		;KEEP GOING
  D4B4   2DA0 D5F2      ERA02	CALL	@WRBAT		;UPDATE DISK VERSION OF BAT
  D4B8   04C1           	CLR	R1		;DONE
  D4BA   2DC0           	RET	
  D4BC   0701           ERAERR	SETO	R1
  D4BE   2DC0           	RET
                        ;
                        ;*********************************
                        ;
                        ;	READ IN THE DIRECTORY
                        ;
                        ;	ENTER WITH  R8 -> FCB
                        ;
                        ;
                        ;*********************************
  D4C0   C0E0 D17A      DIROPN:	MOV	@CDSECT,R3		;ASSUME CURRENT DIRECTORY SECTPR THIS HAS BEEN SET
  D4C4   0200 0008      	LI	R0,DIR_LBA		;GET FIRST DIRECTORY LBA
  D4C8   0A13           	SLA	R3,1		;2 LBAS PER SECTOR
  D4CA   A0C0           	A	R0,R3		;R3 HOLDS THE LBA
  D4CC   C803 D178      	MOV	R3,@LBA+2		;SET THE SECTOR TO READ
  D4D0   0202 D83E      	LI	R2,DIRBUFF 		;BUFFER TO USE
  D4D4   2DA0 D1C0      	CALL	@_SETDMA	 	;BIOS DMA
  D4D8   2DA0 D548      	CALL	@RDREC	 	;READ IN DIRECTORY
  D4DC   0203 D83E      	LI	R3,DIRBUFF		;USE SAME BUFFER 
  D4E0   2DC0           	RET
                        ;
                        ;
                        ;==============================================================
                        ;	FIND THE NEXT DIRECTORY ENTRY
                        ;	DIRENT IS JUST AN OFFSET INTO THE 
                        ;	DIRECTORY BUFFER. ITS VALUUE DEPENDS ON 
                        ;	THE BLOCK SIZE.
                        ;
                        ;	R3 -> TO FILE DIRECTORY CONTENTS
                        ;===============================================================
                        ;
  D4E2   05A0 D170      DIRBLK:	INC	@DIRENT	 	;UP THE LAST ENTRY, INITIALISED TO -1
  D4E6   C0E0 D170      	MOV	@DIRENT,R3
  D4EA   0A53           	SLA	R3,5		;*32 IE 32 BYTES DIRECTORY ENTRY
  D4EC   0223 D83E      	AI	R3,DIRBUFF		;POINT TO NEXT ENTRY
  D4F0   0283 DA3E      	CI	R3,DIRBUFF+BUFSIZ	;HAVE WE REACHED THE END OF THE BUFFER
  D4F4   1A0D           	JL	DIRB01		;NO
  D4F6   05A0 D17A      	INC	@CDSECT	 	;NOW - TRY NEXT SECTOR
  D4FA   C0E0 D17A      	MOV	@CDSECT,R3		;R3 HOLDS RECORD OFFSET WITHIN BLOCK
  D4FE   0283 0004      	CI	R3,NDSECT		;NUMBER OF SECTORS ALLOCATED TO DIRECTORY
  D502   1409           	JHE	DIRB03		;SHOW END OF DIRECTORY
  D504   2DA0 D4C0      	CALL	@DIROPN		;READ THE DIRECTORY
                        ;
                        ;SHOULD THIS BE SET TO ONE OR CLR'D?
                        ;	CLR	@DIRENT		;RESET FOR NEXT TIME
  D508   0720 D170      	SETO	@DIRENT		;RESET FOR NEXT TIME
  D50C   0203 D83E      	LI	R3,DIRBUFF		;-->DIRECTORY ENTRY
  D510   04C1           DIRB01:	CLR	R1		;FLAG SET
  D512   C041           DIRB02:	MOV	R1,R1	 	;SET STATUS
  D514   2DC0           	RET
  D516   0701           DIRB03:	SETO	R1
  D518   10FC           	JMP	DIRB02
                        ;
                        ;******************************
                        ;
                        ;	CONVERT CRN TO BLOCK NUMBER (CRNTBC)
                        ;
                        ;	THIS ROUTINE SIMPLY DIVIDES RECORD NUMBER
                        ;	BY BLOCK SIZE TO GIVE A RELATIVE BLOCK NO
                        ;	SO THAT THE BAT MAY BE INDEXED VIA RESULT
                        ;	IN R2.
                        ;
                        ;*******************************
                        ;
  D51A   C0E8 001A      CRNTBC:	MOV	@CRN(R8),R3 	;NEXT RECORD TO READ
                        ;
                        ;	ENTER HERE IF GENERAL RELATIVE CONVERSION REQUIRED
                        ;	R3 MUST HOLD RECORD NUMBER - NOTE RELATIVE OFFSET WITHIN BLOCK IS FOUND
                        ;	RECORDS BEGIN AT 1
                        ;	BLOCKS BEGIN AT 0
                        ;
  D51E   04C2           RECTBC	CLR	R2	 	;FOR DIVIDE
  D520   0200 0004      	LI	R0,SECBLK	 	;SECTORS/BLOCK
  D524   3C80           	DIV	R0,R2	 	;R2 & R3 HOLD RESULT
  D526   2DC0           RECTBC1	RET
                        ;
                        ;------------------------------------------------------------------------
                        ;
                        ;	BLOCK NO. TO TRK/SECT CONVERSION
                        ;
                        ;	THIS ROUTINE WILL CONVERT A GIVEN BLOCK AND
                        ;	AND RECORD NUMBER WITHIN A FILE TO A PHYSICAL
                        ;	TRACK AND SECTOR. I.E. YOU MAY WISH TO LOCATE
                        ;	THE TRACK/SECTOR OF SAY RECORD 3 WITHIN BLOCK
                        ;	10 ETC.
                        ;
                        ;	THIS ROUTINE IS NORMALLY CALLED AFTER A CALL
                        ;	TO CRNTBC/RECTBC WITHIN RDSEQ ,WRSEQ ETC.
                        ;
                        ;	R1 = BLOCK NO.
                        ;	R3 = RECORD OFFSET WITHIN BLOCK
                        ;
                        ;	RECORDS BEGIN AT 1
                        ;	BLOCKS BEGIN AT 0
                        ;
                        ;	RETURN WITH R2=TRACK,R3=SECTOR
                        ;
                        ;	TRK = INT((BLK*SECBLK + R3)/SECTRK)
                        ;	SECT = REMAINDER(BLK...)+1		
                        ;
                        ;	R2 = TRK, R3 = SECT
                        ;
                        ; NOTE NEEDED TO REMOVE THE MULTIPY AS IT HAS A BUG.  SEE 99105 ERRATA
                        ;------------------------------------------------------------------------
                        ;
                        ;REVISED MULTIPLY TO AVOID 99105 MULTIPLY BUG
                        ;
                        
                        ;BTTSC	LI	R0,SECBLK
                        ;	CLR	R2
                        ;	JEQ	BTTSC2
                        ;BTTSC1	A	R1,R2		;R2=BLK*SECBLK
                        ;	DEC	R0
                        ;	JNE	BTTSC1
                        ;BTTSC2	A	R2,R3		;R3=BLK*SECBLK+R3
                        ;	CLR	R2		;MSB OF QUOTIENT
                        ;	LI	R0,SECTRK		;SECTORS/TRACK
                        ;	DIV	R0,R2	 	;R2=TRK,R3=SECT (R2+R3)/R0
                        ;	INC	R3		;TAKES CARE OF ZERO OFFSET FOR CRN
                        ;BTTSC0	RET
                        ;
                        ;*******************************
                        ;
                        ;	
                        ;	FIND A FREE BLOCK	
                        ;	NXTBLK WILL TRAVERSE THE BAT LOOKING FOR A ZEROED
                        ;	BAT ENTRY.  ONCE FOUND NO CHANGE TO THE BAT WILL BE
                        ;	MADE AND ONLY THE POINTERS TO THE ENTRY WILL BE RETURNED.
                        ;	IT IS THEN UP TO THE CALLING PROGRAMME TO INSERT THE NEW
                        ;	LINKS.
                        ;
                        ;	NOTE: RDBAT WILL PULL IN THE APPROPRIATE BAT SECTOR AS REQUIRED
                        ;
                        ;	R8 -> FCB
                        ;
                        ;	R1 = -1 (ERROR)
                        ;	R1 = 0  (GOOD RESULT)
                        ;	
                        ;
                        ;****************************************************************
                        ;
  D528   C020 D168      NXTBLK:	MOV	@CAB,R0			;BEGIN AT LAST BLOCK TO SPEED THINGS UP AND TO STOP THRASHING
                        
  D52C   C0C0           NXTBLK2	MOV	R0,R3
  D52E   2DA0 D598      	CALL	@GETBATP			;FIND THE BAT AND GET THE POINTER FROM THE INDEX
                        
  D532   C057           	MOV	*R7,R1			;POINTER IS IN R7
  D534   1305           	JEQ	NXTBLK4			;ANY FREE ? YES
  D536   0281 FFFF      	CI	R1,-1			;LAST AVAILABLE BLOCK ?
  D53A   1304           	JEQ	NXTBLK3			;YES
  D53C   0580           	INC	R0			;NEXT BLOCK
  D53E   10F6           	JMP	NXTBLK2			;KEEP LOOKING
                        ;
                        ; R7 -> FREE BLOCK
                        ; R6 =  FREE BLOCK NUMBER
                        ;
  D540   C180           NXTBLK4	MOV	R0,R6			;COPY FREE BLOCK NUMBER HERE
  D542   04C1           	CLR	R1			;SHOW SUCCESS
  D544   C041           NXTBLK3	MOV	R1,R1			;RETURN WITH RESULT CONDINTION SET
  D546   2DC0           	RET 
                        ;
                        ;****************************
                        ;
                        ;	READ A RANDOM RECORD
                        ;	R8 -> FCB
                        ;	R3 -> LBA
                        ;
                        ;******************************
                        
  D548   C120 D174      RDREC:	MOV	@DMAADDR,R4
  D54C   2DA0 F01C      	CALL	@MRDREC	 	;READ THE RECORD IN
                        ;	CLR	R1
  D550   C041           	MOV	R1,R1	 	;ERROR ?
  D552   1301           	JEQ	RDREC1	 	;NO
  D554   0701           RDERR	SETO	R1	 	;SHOW ERROR
  D556   C041           RDREC1	MOV	R1,R1
  D558   2DC0           	RET
                        ;
                        ;******************************
                        ;
                        ;	WRITE A RANDOM RECORD
                        ;	R8 -> FCB
                        ;	R3 -> LBA
                        ;
                        ;*****************************
                        ;
  D55A   C120 D174      WRREC:	MOV	@DMAADDR,R4
                        ;	CLR R1
  D55E   2DA0 F020      	CALL	@MWRREC
  D562   C041           	MOV	R1,R1	
  D564   1301           	JEQ	WRREC_X
  D566   0701           WRERR	SETO	R1
                        
  D568   C041           WRREC_X	MOV	R1,R1
  D56A   2DC0           	RET
                        ;
                        ;*************************************************
                        ;*
                        ;*   TRACE THE FILES LINKED LIST AND FIND THE 
                        ;*   BAT ENTRY CORRESPONDING TO THE FILE'S NTH
                        ;*   BLOCK.
                        ;*   ENTER WITH FILES RELATIVE RECORD IN R2 (SET TO -1 IF LAST LINK REQUIRED)
                        ;*   EXIT  WITH DBN (DISK BLOCK NUMBER ) POINTER IN R7
                        ;*   AND WITH R1=R2 IF MATCH TO R1 AND R1=0FFF8 IF LAST LINK
                        ;*
                        ;*   CALL TRACES WITH FSB/CAB DURING WRSEQ TO SPEED UP TRACE
                        ;*
                        ;**************************************************
                        ;
  D56C   C0E8 000C      TRACE:	MOV	@FSB(R8),R3		;GET FIRST FILE BLOCK - THIS IS THE START OF THE LINK
  D570   04C1           	CLR	R1		;COUNTER
  D572   2DA0 D598      TRACE1	CALL	@GETBATP		;GET THE BLOCK POINTER TO REQUESTED BAT ENTRY IN R7
  D576   C117           	MOV	*R7,R4		;GET NEXT ALLOCATION LINK
  D578   0284 FF80      	CI	R4,LASTBLK		;IS IT THE LAST BLOCK ?
  D57C   1308           	JEQ	TRACE3		;YES
  D57E   8081           	C	R1,R2		;HAVE WE REACHED THE WANTED BLOCK YET ?
  D580   1306           	JEQ	TRACE3		;YES
  D582   0581           	INC	R1		;BUMP THE RECORD POINTER
  D584   C0C4           	MOV	R4,R3		;GET THE LINK AND KEEP GOING
  D586   1301           	JEQ	TRACE2		;CAN'T IMAGINE WHY ?
  D588   10F4           	JMP	TRACE1
  D58A   0701           TRACE2	SETO	R1
  D58C   2DC0           	RET
  D58E   C807 D16A      TRACE3	MOV	R7,@CBP		;CURRENT BLOCK POINTER
  D592   C803 D168      	MOV	R3,@CAB		;AND CURRENT NUMBER
  D596   2DC0           	RET
                        ;
                        ; GETBATP (GET BAT POINTER) CHECK TO SEE IF THE BAT NUMBER (WHICH WILL
                        ; INDEX INTO THE BAT) PASSED
                        ; IN R3 LIES WITHIN THE RANGE OF THE CURRENT
                        ; BAT WHICH IS IN MEMORY. IF NOT IT WILL READ
                        ; THE APPRORIATE BAT INTO THE BUFFER
                        ; R7 WILL BE RETURNED AS A POINTER TO THE INDEXED ELEMENT
                        ; REGISTERS R0->R5 ARE PRESERVED
                        ;
  D598   2D05           GETBATP: 	PUSHREG	R5
  D59A   C003           	MOV	R3,R0		;THIS IS THE CAB (CURRENTLY ALLOCATED BLOCK)
  D59C   0980           	SRL	R0,BATSF		;DETERMINE CURRENT BAT PAGE OR SECTOR BASED ON 256 BLOCKS PER PAGE
  D59E   8800 D16E      	C	R0,@CBSECT		;CURRENT BAT SECTOR IN MEMORY
  D5A2   1303           	JEQ	FBAT0		;IN MEMORY
  D5A4   C040           	MOV	R0,R1		;BAT SECTOR TO BE READ IN
  D5A6   2DA0 D5BA      	CALL	@RDBAT		;UPDATE MEMORY VERSION OF BAT
                        ;
                        ;	WE HAVE CROSSED TO ANOTHER BAT PAGE, NEED TO ADJUST
                        ;
  D5AA   2D45           FBAT0	POPREG	R5		;NEED TO POP HERE TO GET R3
  D5AC   C1C3           	MOV	R3,R7
  D5AE   0A17           	SLA	R7,1		;TWO BYTES PER ENTRY AND MAKES IT WORD EVEN
  D5B0   0247 00FF      	ANDI	R7,BATMSK		;MASK OFF HIGH BITS SO WE JUST HAVE THE BLOCK INDEX INTO THE 256 BAT ENTRY PAGE
  D5B4   0227 D63E      	AI	R7,BATBUFF		;R7->INDEXED ELEMENT
  D5B8   2DC0           	RET			;ALL IS OKAY
                        ;
                        ;	READ IN THE BAT
                        ;	R1 HOLDS CURRENT BAT SECTOR TO READ IN 
                        ;	DON'T CHECK IF ALREADY IN MEMORY AS THE CALLING ROUTINE WILL DO THAT
                        ;	R1=0 FOR 1ST 1 FOR 2ND ETC
                        ;
  D5BA   C020 D63A      RDBAT:	MOV	@BATCHG,R0		;IF THERE HAS BEEN A CHANGE FIRST UPDATE
  D5BE   0580           	INC	R0
  D5C0   1607           	JNE	RDBAT1		;NO CHANGE SO PERFORM AS REQUESTED
                        ;
                        ;	WRITE MODIFIED BAT TO DISC
                        ;
  D5C2   8801 D16E      RDBAT0	C	R1,@CBSECT		;IF BAT SECTOR IN MEMORY EXIT
  D5C6   1314           	JEQ	RDBAT2
  D5C8   2E01           	PUSH	R1		;CHANGE SO DON'T READ IF IF NOT NECESSARY
  D5CA   2DA0 D5F2      	CALL	@WRBAT		;FORCE UPDATE OF DISK BAT
  D5CE   2E41           	POP	R1
  D5D0   C801 D16E      RDBAT1	MOV	R1,@CBSECT		;NEW SECTOR
  D5D4   0203 0002      	LI	R3,BAT_LBA
  D5D8   0A11           	SLA	R1,1		;2 LBAS PER SECTOR
  D5DA   A0C1           	A	R1,R3		;THIS IS THE BAT
  D5DC   C803 D178      	MOV	R3,@LBA+2		;JUST IN CASE
  D5E0   0204 D63E      	LI	R4,BATBUFF 		;USE THIS BUFFER
  D5E4   2DA0 F01C      	CALL	@MRDREC	 	;READ THE RECORD IN
  D5E8   C041           	MOV	R1,R1	 	;ERROR ?
  D5EA   1302           	JEQ	RDBAT2	 	;NO
  D5EC   0701           	SETO	R1	 	;SHOW ERROR
  D5EE   C041           	MOV	R1,R1
  D5F0   2DC0           RDBAT2	RET
                        ;
                        ;	WRITE OUT A BAT SECTOR
                        ;	CBSECT HOLDS BAT SECTOR TO BE WRITTEN TO DISK
                        ;
  D5F2   C0A0 D16E      WRBAT:	MOV	@CBSECT,R2 		;BAT SECTOR; 1 TO 3
  D5F6   0203 0002      	LI	R3,BAT_LBA
  D5FA   0A12           	SLA	R2,1		;2 LBAS PER SECTOR
  D5FC   A0C2           	A	R2,R3
  D5FE   C803 D178      	MOV	R3,@LBA+2		;JUST IN CASE
  D602   0204 D63E      	LI	R4,BATBUFF		;USE SAME BUFFER
  D606   2DA0 F020      	CALL	@MWRREC
  D60A   C041           	MOV	R1,R1
  D60C   1301           	JEQ	WRB_X
  D60E   0701           	SETO	R1
  D610   C041           WRB_X	MOV	R1,R1
  D612   04E0 D63A      	CLR	@BATCHG		;DISK BM NOW EQUALS MEMORY VERSION
  D616   2DC0           	RET
                        
                        ;
                        ;
                        ;  WRITE OUT THE DIRECTORY TO THE DISC.
                        ;  R8 HOLDS THE FCB
                        ;
                        ;DB_WRDIR:	TEXT	"WRDIR"	;TEMP FOR DEBUG
                        ;	WORD	0
                        ;	EVEN
  D618   C0E0 D17A      WRDIR:	MOV	@CDSECT,R3		;R3 HOLDS RECORD OFFSET WITHIN BLOCK
  D61C   0A13           	SLA	R3,1		;TWO LBAS PER SECTOR
  D61E   0200 0008      	LI	R0,DIR_LBA		;FIRST DIRECTORY ENTRY LBA VALUE
  D622   A0C0           	A	R0,R3
  D624   C803 D178      	MOV	R3,@LBA+2		;SET THE LBA - NOT SURE THIS IS NECESSARY
  D628   0204 D83E      	LI	R4,DIRBUFF
                        ;
                        ; CALL TO MWRREC
                        ; R3 HOLDS THE LSB OF THE LBA VALUE FOR THE SECTOR WE WANT TO READ OR WRITE
                        ; R4 HOLDS THE BUFFER ADDRESS
                        ;
  D62C   2DA0 F020      	CALL	@MWRREC
  D630   C041           	MOV	R1,R1
  D632   1301           	JEQ	WRD_X
  D634   0701           	SETO	R1
                        
  D636   C041           WRD_X	MOV	R1,R1
  D638   2DC0           	RET
                        
                        ;
                        ;======================================================
                        ;	MAP THE TRACK NUMBER IN R2 TO
                        ;	EITHER SIDE 0 OR SIDE 1
                        ;
                        ;	RETURN IN R2 AND @TRACK
                        ;========================================================
                        ;
                        ;SETTRK:	CI	R2,TRKDSK		;CHECK FOR SIDE 2
                        ;	JLT	SETTRK1
                        ;	AI	R2,-2*TRKDSK
                        ;	INC	R2
                        ;	NEG	R2
                        ;	ORI	R2,8000H		;SET MSB TO INDICATE SIDE 1
                        ;SETTRK1:
                        ;	MOV	R2,@TRACK
                        ;	RET
                        ;
                        ;
                        ;	BUFFERS ETC
                        ;
                        ;	THE FLAG BATCHG(BIT MAP CHANGE) IS SET WHENEVER AN ALLOCATION
                        ;	BIT IN THE BLOCK ALLOCATION TABLE (BAT)HAS BEEN 
                        ;	CLEARED/ALLOCATED. THIS ENSURES THAT THE BAT
                        ;	WILL NOT BE OVERWRITTEN BY THE DISK VERSION OF THE BIT MAP.
                        ;	THIS FLAG IS CLEARED ONCE A BIT MAP DISK WRITE IS FORCED BY
                        ;	A FILE CLOSURE OR A DIRECTORY FSB BEING REQUESTED.
                        ;
  D63A   0000           BATCHG:	WORD	0		;BAT CHANGE FLAG
  D63C   0000           MCNT:	WORD	0		;BYTES LEFT IN BUFFER
  D63E                  BATBUFF:	BSS	BUFSIZ		;BAT BUFFER
  D83E                  DIRBUFF:	BSS	BUFSIZ		;DIRECTORY BUFFER
                        INTBUFF:
  DA3E                  MLBUF:	BSS	BUFSIZ		;BUFFER FOR C COMPILED PROGRAMMES
                        
                        ;
  DC3E                  	END

No error(s).
GETSIZ           D380  DMAADDR          D174  LRBL             0014  SECBLK           0004  
EXIT             D160  DIRBLK           D4E2  ALLONES          D165  FUN01            D110  
PUSH             2E00  FUN11            D124  BLK2_LBA         0012  FUN21            D138  
GETSIZ1          D390  FUN31            D14C  NAM              0000  FINAL_LBA        0010  
CMLTI            0020  DLOOK            D3A0  WRBAT            D5F2  WRCMD            0002  
RENAM2           D45E  NAMEOFF2         0012  WRRND            D33A  BATCHG           D63A  
RENAME           D43E  DLOOK1           D3A6  ERAERR           D4BC  DLOOK4           D3B2  
RDERR            D554  DLOOK5           D3C4  CBP              D16A  DLOOK6           D3C8  
FBAT0            D5AA  FSB              000C  BATMSK           00FF  TRACE            D56C  
FUN08            D11E  GETBATP          D598  FUN28            D146  MMLTA            D242  
FCLOSE           D260  WRD_X            D636  FUN04            D116  LASTBLK          FF80  
FUN24            D13E  TRACE1           D572  POPREG           2D40  TRACE2           D58A  
R1               0001  BDOS0            D17E  R3               0003  TRACE3           D58E  
R2               0002  MWBOOT           F028  R7               0007  DMAFUN           D1B6  
R8               0008  MONITOR          F000  RDSEQ            D2EE  DB_FCLOSE        D258  
FUN00            D10E  MRDREC           F01C  FUN20            D136  RDREC            D548  
FUN40            D15E  MAKEMLT          D234  FDIRRN           0004  MON_PTR          0086  
POP              2E40  RDREC1           D556  FLA              0010  RWREC            D348  
NXTLTR           D3B8  CBN              0018  NEWPAGE          2C80  CIN              D194  
CBSECT           D16E  NXTBLK2          D52C  WRERR            D566  CRN              001A  
OPENA            D1EA  RWREC_R          D364  MLBUF            DA3E  FUN06            D11A  
NXTBLK           D528  FUN16            D12E  PUSHREG          2D00  FUN26            D142  
NONTRY           D3D0  FUN36            D156  MAKERR           D43A  GETMLT           D20C  
SWPAGE           2CC0  RET              2DC0  FUN09            D120  LBA              D176  
FUN29            D148  BDOS             D100  INTBUFF          DA3E  BATBUFF          D63E  
WRSEQ            D28A  FUN02            D112  FUN15            D12C  FUN12            D126  
FUN35            D154  FUN22            D13A  WRSEQ1           D2EA  FUN32            D14E  
WRSEQ0           D2CA  DIRBUFF          D83E  DIROPN           D4C0  MKFIL1           D424  
BATSF            0008  MKFIL2           D408  BOOT_LBA         0000  DIRB01           D510  
DCONIO           D19C  DIRB02           D512  NSIDES           0002  DIRB03           D516  
RENAM1           D454  DIRSIZ           0020  MCONOUT          F00C  CAB              D168  
MCNT             D63C  OPENENT          D1F0  DISK             D166  RELB             001C  
SEARCH2          D378  BYTSEC           0200  FUN38            D15A  RELR             001E  
FUN14            D12A  WRREC            D55A  R0               0000  _SETDMA          D1C0  
R4               0004  CDFUNC           D1B0  R5               0005  RSVDSEC          0001  
RDSEQ1           D320  CLOSEB           D288  FUN30            D14A  RECTBC           D51E  
FCLOSE1          D27A  MPAGE            0022  RDCMD            0001  RDBAT            D5BA  
WRREC_X          D568  RDRND            D324  MRDID            F024  RDBAT0           D5C2  
WHEX             2E80  SETREL           D392  RECLAIM          D480  RDBAT2           D5F0  
DIR_LBA          0008  RDBAT1           D5D0  FUN19            D134  ERA00            D4A2  
DEBUG            2FC0  MRECAL           F014  FUN25            D140  CRNTBC           D51A  
WRSEQ2           D2EC  CBO              D16C  CCMD             D17C  NXTBLK3          D544  
FTY              000B  RECTBC1          D526  WRB_X            D610  SEARCH1          D368  
LBASECT          0001  FUN07            D11C  NXTBLK4          D540  FUN17            D130  
MCONIN           F008  FUN27            D144  CALL             2D80  FUN37            D158  
MAKFIL           D3D4  MSELDSK          F010  MSEEK            F018  NTHR             D3F2  
OPENE            D208  SECTRK           0012  MINUS1           FFFF  DIRTRK           0000  
BAT_LBA          0002  BATTRK           0000  FUN39            D15C  FOPEN            D1D0  
NBATS            0001  ERAFIL           D460  WILD             D164  FBATSEC          0002  
WRDIR            D618  MLOAD            D1C6  FUN18            D132  NDSECT           0004  
R6               0006  FUN03            D114  FSZ              000E  FUN13            D128  
ERA02            D4B4  FUN23            D13C  FUN05            D118  FUN33            D150  
WRADDR           D172  DIRENT           D170  FUN34            D152  NMSECT           0021  
BUFSIZ           0200  ERA01            D4A6  FUN10            D122  COUT             D18A  
DSKFUN           D1A6  MWRREC           F020  NAMSIZ           000B  CDSECT           D17A  
