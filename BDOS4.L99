                        ;
                        ;---------------------------------------------------------
                        ;
                        ;	BDOS FOR THE 9900/99000
                        ;
                        ;	WRITTEN	BY ALEXANDER.CAMERON
                        ;
                        ;	DURING JULY 1983.
                        
                        ;	18 NOV 2019	BDOS IS CONFIGURED TO SHARE CALLING PROGRAMME WORKSPACE AND STACK
                        ;		THAT IS IT DOES NOT DEFINE ITS OWN STACK
                        ;	25 MAY 2024	NEW VERSION 3 TO INCORPORATE IDE HARD DRIVE - FLOPPY I/F WILL BE REMOVED
                        ;	26 AUGUST 2024	NEW VERSION 4 TO ADD MODULE LOAD CAPABILITY TO ALLOW FOR SEGMENTED MEMORY
                        ;
                        ;
                        ;-----------------------------------------------------------
                        ;
                        ; DEFINE XOP FUNCTIONS
                        ; THESE XOP ARE DEFINED IN THE MONITOR.
                        ; BECAUSE THE XOP WORKSPACES OVERLAP,
                        ; THEN R0 TO R7 ARE SHARED WHEN A CALL FUNCTION OCCURS.
                        ;
                        ;
                        ;
                        ;
                        ;	DEFINE SOME XOP'S DEFINED IN MONITOR
                        ;
                        	;DXOP	NEWPAGE,2
                        	;DXOP	SWPAGE,3
                        	DXOP	PUSHREG,4
                        	DXOP	POPREG,5
                        	DXOP	CALL,6
                        	DXOP	RET,7
                        	DXOP	PUSH,8
                        	DXOP	POP,9
                        	DXOP	WHEX,10		;WRITE OUT A 16 BIT HEX VALUE
                        ;	DXOP	RHEX,11		;READ IN A 16 BIT HEX VALUE
                        ;	DXOP	WRITE,12		;WRITE CHAR IN MSB
                        ;	DXOP	READ,13		;READ CHAR IN MSB
                        ;	DXOP	MESG,14		;OUTPUT NULL TERMINATED MESSAGE
                        	DXOP	DEBUG,15
                        ;
                        ;	REGISTER EQUATES
                        ;
  0000                  R0	EQU	0
  0001                  R1	EQU	1
  0002                  R2	EQU	2
  0003                  R3	EQU	3
  0004                  R4	EQU	4
  0005                  R5	EQU	5
  0006                  R6	EQU	6
  0007                  R7	EQU	7
  0008                  R8	EQU	8
                        
                        ;
                        ; OPERATING SYSTEM EQUATES
                        ;
  F000                  MONITOR	EQU	0F000H
  D100                  BDOS	EQU	0D100H
                        ;		;
  D100                  	AORG	BDOS
                        ;
                        ; BDOS ENTRY POINT;  BDOS IS CALLED VIA XOP CALL SO THAT
                        ;
  D100   0A12           	SLA	R2,1		;ADJUST FOR JUMP
  D102   0282 0050      	CI	R2,2*40		;MAKE SURE IT A LEGAL VALUE
  D106   1B2C           	JH	EXIT	
  D108   C022 D10E      	MOV	@FUN00(R2),R0
  D10C   0450           	B	*R0
                        ;
                        
                        ;#define GETPOS   36  /* get number of current sector */
                        ;#define GOCPM    00  /* go to CP/M */
                        ;#define LSTOUT   05  /* list output */
                        ;#define POSEND   35  /* position file to end */
                        ;#define RDRINP   03  /* reader input */
                        
                        
                        ;
                        ;	JUMP TABLE - ENTER WITH VALUE IN R3
                        ;
  D10E   D17E           FUN00	WORD	BDOS0			;WARM BOOT		
  D110   D194           FUN01	WORD	CIN			;CONSOLE INPUT
  D112   D18A           FUN02	WORD	COUT	 		;CONSOLE OUTPUT (OUTPUT LSB OF R3)
  D114   D160           FUN03	WORD	EXIT	
  D116   D160           FUN04	WORD	EXIT	
  D118   D160           FUN05	WORD	EXIT	
  D11A   D19C           FUN06	WORD	DCONIO			;DIRECT CONSOLE IO		
  D11C   D160           FUN07	WORD	EXIT	 
  D11E   D160           FUN08	WORD	EXIT	
  D120   D160           FUN09	WORD	EXIT	
  D122   D160           FUN10	WORD	EXIT	
  D124   D160           FUN11	WORD	EXIT	
  D126   D160           FUN12	WORD	EXIT	
  D128   D160           FUN13	WORD	EXIT	
  D12A   D1A6           FUN14	WORD	DSKFUN			;SELECT A DISK 
  D12C   D1DC           FUN15	WORD	FOPEN	 		;OPEN A FILE
  D12E   D26C           FUN16	WORD	FCLOSE	 		;CLOSE A FILE
  D130   D374           FUN17	WORD	SEARCH1	 		;LOOK FOR A FILE
  D132   D384           FUN18	WORD	SEARCH2			;SEARCH NEXT
  D134   D46C           FUN19	WORD	ERAFIL	 		;ERASE A FILE
  D136   D2FA           FUN20	WORD	RDSEQ	 		;READ SQUENTIAL
  D138   D296           FUN21	WORD	WRSEQ	 		;WRITE SQUENTIAL
  D13A   D3E0           FUN22	WORD	MAKFIL	 		;MAKE A FILE
  D13C   D44A           FUN23	WORD	RENAME			;RENAME A FILE	
  D13E   D160           FUN24	WORD	EXIT	
  D140   D1B0           FUN25	WORD	CDFUNC			;RETURN CURRENT DISK
  D142   D1B6           FUN26	WORD	DMAFUN			;SET DMA ADDRESS
  D144   D1C6           FUN27	WORD	MLOAD	 		;LOAD MODULES FROM TABLE
  D146   D160           FUN28	WORD	EXIT	 		;
  D148   D160           FUN29	WORD	EXIT	 		;
  D14A   D160           FUN30	WORD	EXIT	 		;
  D14C   D160           FUN31	WORD	EXIT	 		;
  D14E   D160           FUN32	WORD	EXIT	 		;
  D150   D330           FUN33	WORD	RDRND	 		;READ A RANDOM RECORD
  D152   D346           FUN34	WORD	WRRND	 		;WRITE A RANDOM RECORD
  D154   D38C           FUN35	WORD	GETSIZ			;GET FILE SIZE
  D156   D39E           FUN36	WORD	SETREL			;SET RELATIVE RECORD
  D158   D160           FUN37	WORD	EXIT
  D15A   D160           FUN38	WORD	EXIT
  D15C   D160           FUN39	WORD	EXIT
  D15E   D160           FUN40	WORD	EXIT
  D160   0701           EXIT	SETO	R1			;ERROR 
  D162   2DC0           	RET
                        
                        ;
                        ; BIOS EQUATES
                        ;
                        ;
                        ;TEMPORARY TESTING ADDRESS TO MIMIC MONITOR BEING AT LOCATION F000
  0086                  MON_PTR	EQU	086H			;LOW MEMORY POINTER TO MONITOR
                        ;
                        ;	BIOS VECTORS ARRANGED AS N*L WHERE
                        ;
                        ;	N IS THE NTH VECTOR IN THE MONITOR, AND
                        ;	L IS THE NUMBER OF BYTES PER VECTOR
                        ;
                        ;	WHEN CALLING MRDREC, MWRREC ETC IT IS NECESSARY TO CALL USING
                        ;	LBA VALUES, NOT SECTORS.
                        ;
  F008                  MCONIN	EQU	MONITOR+2*4	;CONSOLE IN
  F00C                  MCONOUT	EQU	MONITOR+3*4	;CONSOLE OUT
  F010                  MSELDSK	EQU	MONITOR+4*4	;SET CURRENT LOGGED DRIVE
  F01C                  MRDREC	EQU	MONITOR+7*4	;READ A STANDARD RECOR0D
  F020                  MWRREC	EQU	MONITOR+8*4	;WRITE A STANDARD RECORD
  F014                  MRECAL	EQU	MONITOR+5*4
  F018                  MSEEK	EQU	MONITOR+6*4
  F024                  MRDID	EQU	MONITOR+9*4
  F028                  MWBOOT	EQU	MONITOR+10*4		;WARM BOOT
                        ;
                        ;************************************************************************************************************
                        ;
                        ;	FCB EQUATES
                        ;
                        ;	THE FCB CONSISTS OF 36 BYTES OF DATA:
                        ;	ONLY BYTES 0 TO 31 ARE AN EXACT COPY OF THE DIRECTORY ENTRY
                        ;
                        ;	   
                        ;	   BYTES	FUNCTION
                        ;	   -----        --------
                        ;	   0 -7	FILENAME
                        ;	   8 -10 	FILENAME EXTENSION
                        ;	   11	FTY  - FILE TYPE
                        ;	   12-13	FSB  - FILE'S STARTING BLOCK
                        ;	   14-15 	FSZ  - FILE SIZE IN RECORDS (A RECORD IS EQUIVALENT TO A SECTOR)
                        ;	   16-17 	FLA  - FILE LOAD ADDRESS - USED TO DETERMINE WHERE FILE WILL LOAD
                        ;	   18-19	FSZBH - FILE SIZE IN BYTES HIGH WORD
                        ;	   20-21	LRBL - THIS LAST RECORD BYTE LENGTH OR NUMBER OF BYTES IN THE LAST RECORD
                        ;		SO ACTUAL FILE SIZE IN BYTES IS 512*FSZ - (512 - FSZBL)
                        ;	   22-23 	SPARE COULD MAKE THIS DATE
                        ;	   24-25	CBN  - FILE'S CURRENT BLOCK NUMBER
                        ;	   26-27	CRN  - CURRENT RECORD NUMBER - DATA BEGINS AT CRN=1.  CRN=O is the MODULE LOAD TABLE
                        ;	   28-29	RELB - RELATIVE BLOCK NUMBER
                        ;	   30-31 	RELR - RELATIVE RECORD NUMBER FILE WILL LOAD.
                        ;
                        ;	-----------------32 to 36 ARE TRANSIENT VALLUES AND NOT IN THE DIRECTORY------------------
                        ;	   .
                        ;	   32	CMLTI - THIS IS THE CURRENT MODULE LOAD INDEX.  JUST ONE BYTE I.E UP TO 256 MODULES
                        ;	   33	NMSECT - MODULE SIZE IN SECTORS. THIS IS THE NUMBER OF RECORDS IN THE PARTICULAR MODULE;
                        ;		WHICH IN POINTED TO MY CMLTI
                        ;	   34	MEMORY PAGE TO LOAD
                        ;	   34 	DRIVE
                        ;	   35 	LBUFCNT - NUMBER BYTES IN LAST BUFFER.  ALLOWS TO MANAGE BINARY FILES SO CPMEOF IS NOT NEEDED
                        ;
                        ;	THE LBA VALUES SEQUENTIALLY GO FROM 0, 2, 4 ETC BECAUSE WE ARE READING BYTES BACK FROM THE DRIVE
                        ;	RATHER THAN 16 BITS , SO TWO 256 READS (2 LBAs) WILL EQUAL 512 BYTES WHICH IS THE NOMINAL BYTES PER SECTOR
                        ;	DISC STRUCTUR.  EACH SECTOR READ WILL READ IN 2 SECTORS
                        ;	[LBA0][LBA2][LBA4][LBA6][LBA8][LBA10][LBA12][LBA14]<-------FILES BEGIN AT BLOCK 2
                        ;	[BOOT][BAT1][BAT2][BAT3][DIR1][DIR2 ][DIR3 ][DIR4 ][REC1BLK2,REC2BLK2,RECS3BLK2,REC4BLK2][REC1BLCK3...ETC]
                        ;	<-------BLOCK 0--------><--------BLOCK 1----------><-----------BLOCK 2------------------>
                        ;
                        ;	EACH BLOCK IS 4 SECTORS OR or 4 x 512 = 2048 Bytes - we can call see the similarity of blocks to pages
                        ;
                        ;	BLOCK ALLOCATION TABLE [BAT] SECTORS ARE INITIALISED TO 0, THUS AVAILABLE BLOCKS ARE INDICATED BY THE VALUE OF 0000H.
                        ;	WITH THE LAST AVAILABLE BLOCK BEING SET TO -1 IN THE LAST BAT PAGE.
                        ;	ALLOCATED BLOCKS HAVE A NON ZERO BLOCK NUMBER POINTING TO THE NEXT BLOCK IN THE LINK AND THE FINAL BLOCK
                        ;	IN THE LINK INDICATED BY A BLOCK NUMBER VALUE OF FF80H WHICH IS A SIMPLE INVERSION OF THE FIRST 9 BITS
                        ;	WHICH ARE UNUSED.
                        ;
                        ;	FOR EXAMPLE, BAT 1 WOULD LOOK LIKE THIS
                        ;
                        ;	BAT 1
                        ;	BLOCK NUMBER	VALUE	COMMENT
                        ;
                        ;	[ 0	FF80   ]	BOOT SECTOR, PLUS BATs OCCUPY A SINGLE BLOCK (BLOCK 0)
                        ;	[ 1	FF80   ]	DIRECTORY SECTORS OCCUPY A SINGLE BLOCK (BLOCK 1)
                        ;	[ 2	0003   ]	POINTS TO NEXT BLOCK IN LINK.  FILE IS SHELL.SYS (2 BLOCKS IN SIZE)
                        ;	[ 3	FF80   ]	LAST BLOCK IN THE FILE
                        ;	[ 4	0005   ]	POINTS TO NEXT BLOCK IN LINK.  FILE IS BDOS.SYS (2 BLOCKS IN SIZE)
                        ;	[ 5	FF80   ]	LAST BLOCK IN THE LINK
                        ;	[ 6	0007   ]	TEST FILE 3 BLOCKS LONG
                        ;	[ 7	0008   ]	2ND BLOCK
                        ;	[ 8	FF80   ]	LAST BLOCK IN FILE
                        ;	[ 9	0000   ]
                        ;	[ 9	0000   ]
                        ;		ETC
                        ;
                        ;	FOR THIS REASON THE FCB MUST CONTAIN THE FILE STARTING BLOCK (FSB) SO THE START  OF THE LINK
                        ; 	CAN BE FOUND.
                        ;
                        ;	BAT SECTORS ARE ORGANSIED AS FOLLOWS:
                        ;
                        ;	BAT SECTOR 1[BLK0,BLK1,BLK2,BLK3.......BLK255]
                        ;	BAT SECTOR 2[BLK256,BLK257,BLK258,.....BLK511]
                        ;	BAT SECTOR 2[BLK512,BLK513,BLK514..... BLK719,-1]
                        ;
                        ;
                        ;	NOTE:  CPM/TDOS OPERATES AT THE RECORD LEVEL SO THE TASK OF TDOS IS TO BE ABLE TO
                        ;	MAP BETWEEN FILE RECORDS LOCATION WITHIN A BLOCK ON THE DISC TRACK AND SECTOR NUMBER
                        ;
                        ;	BAT SECTORS ARE ORGANSISED AS 3 BAT PAGES/SECTOR
                        ;	[PAGE3][PAGE2][PAGE1][ 0 0 0 0 0 0 0 0].
                        ;	SO THE LSB 8 BITS REPRESENT THE ACTUAL BLOCK NUMBER AND THE NEXT 3 BITS THE BAT PAGE NUMBERS
                        ;	BAT 0 = 000, BAT 1 = 001, BAT 2 = 010 AND BAT 3 = 011.
                        ;
                        ;	SO SHIFTING THE BLOCK NUMBER BY 8  SHIFT COUNT AND APPLYING THE MASK 00FFH YIELDS THE PAGE NUMBER
                        ;	TO WHICH THE BLOCK NUMBER BELONGS.
                        ;
                        ;**********************************************************************************************************************
                        ;
  0000                  NAM	EQU	0	
  000B                  FTY	EQU	11		;TYPE 
  0010                  FLA	EQU	16		;FILES LOAD ADDRESS
  001A                  CRN	EQU	26	 	;NEXT RECORD TO READ/WRITE 
  0018                  CBN	EQU	24	 	;CURRENT BLOCK NUMBER
  001C                  RELB	EQU	28		;RANDOM ACCESS RELATIVE BLOCK NUMBER
  001E                  RELR	EQU	30		;RELATIVE RECORD NUMBER
  000C                  FSB	EQU	12		;FILE STARTING BLOCK
  000E                  FSZ	EQU	14		;FILE SIZE IN SECTORS
  0014                  LRBL	EQU	20		;NUMBER OF BYTES IN THE LAST RECORD
  0020                  CMLTI	EQU	32		;CURRENT MLINDEX - 0 REFERS TO MAIN MODULE
  0021                  NMSECT	EQU	33		;NUMBER OF SECTORS/RECORDS IN THE PARTICULAR MODULE
  0022                  MPAGE	EQU	34
                        ;
                        ; MEDIA TYPE 00FDH FLOPPY DISC HAS BEEN DEPRECATED
                        ;
                        ;TRKDSK	EQU	80		;TRACKS PER DISK
  0012                  SECTRK	EQU	18		;SECTORS PER TRACK
  0200                  BYTSEC	EQU	512		;BYTES PER SECTOR
  0004                  SECBLK	EQU	4		;SECTOR PER BLOCK THIS MEANS THERE ARE 2 BAT SECTORS
                        				; 80*18*2/SECBLK = 720 IE 2*512 SECTORS REQUIRED
  0001                  LBASECT	EQU	1		;NUMBER OF LBAS PER SECTOR (DUE TO 256 BYTE READS)
  0001                  RSVDSEC	EQU	1		;RESERVED SECTORS FOR BOOT SECTOR
  0002                  NSIDES	EQU	2		;NUMBER OF SIDES
                        ;SECDSK	EQU	NSIDES*SECTRK*TRKDSK	;SECTORS ON DISK
  0001                  NBATS	EQU	1		;NO OF BAT ENTRIES ie backup etc
  0004                  NDSECT	EQU	4		;NO OF DIRECTORY SECTORS PER DISK
  0002                  FBATSEC 	EQU	RSVDSEC+1		;FIRST BAT SECTOR  OFFSET FROM 0
  0004                  FDIRRN	EQU	4		;FIRST DIRECTORY RECORD NUMBER ()
  0000                  DIRTRK	EQU	0		;DIRECTORY STARTS HERE
  0000                  BATTRK	EQU	0
  0008                  BATSF	EQU	8		;DETERMINES THE BAT PAGE (SEE EXPLANATION ABOVE)
                        ;BATMSK	EQU	01FFH		;BASED ON BYTSEC/2 ENTRIES PER BAT PAGE - USED IN GETBATP
                        ;BATMSK SHOULD BE 00FF
  00FF                  BATMSK	EQU	0FFH		;BASED ON BYTSEC/2 ENTRIES PER BAT PAGE - USED IN GETBATP
  FF80                  LASTBLK	EQU	0FF80H		;INDICATES LAST BLOCK IN A FILE
  0200                  BUFSIZ	EQU	BYTSEC		;DISK BUFFER SIZE
                        ;
  000B                  NAMSIZ	EQU	11		;FILENAME SIZE IN BYTES
  0012                  NAMEOFF2	EQU	18		;2ND NAME OFFSET INTO FCB
  0020                  DIRSIZ	EQU	32		;NO. OF BYTES PER ENTRY
  0001                  RDCMD	EQU	1	 	;READ COMMAND
  0002                  WRCMD	EQU	2	 	;WRITE COMMAND
                        
  FFFF                  MINUS1	EQU	-1		;USED FOR GENERAL ERROR
  D164   3F             WILD	BYTE	'?'
  D165   FF             ALLONES	BYTE	-1		;;USED FOR GENERAL ERROR
  D166                  	EVEN
                        ;
  D166   0000           DISK	WORD	0		;CURRENTLY SELECTED DISK LS BYTE USED
  D168   0000           CAB	WORD	0	 	;CURRENTLY ALLOCATED BLOCK NUMBER
  D16A   0000           CBP   	WORD	0		;CURRENT BAT LOCATION POINTER
  D16C   0000           CBO	WORD	0		;CURRENT OFFSET INTO BLOCK
  D16E   FFFF           CBSECT	WORD	-1		;CURRENT BAT SECTOR IN MEMORY
  D170   0000           DIRENT	WORD	0		;USED IN DIRECTORY SEARCH
  D172   D84A           WRADDR	WORD	DIRBUFF		;CURRENT DMA ADDRESS
  D174   0000           DMAADDR	WORD	0		;CURRENT DMA ADDRESS FOR MONITOR
                        ;TRACK	WORD	0
                        ;SECTOR	WORD	0
  D176   0000 0000      LBA	WORD	0,0		;BOTH THIS AND SECTOR ARE PROBABLY NO NEEDED ANYMORE
  D17A   0000           CDSECT	WORD	0	 	;CURRENT DIRECTORY SECTOR
  D17C   0000           CCMD	WORD	0	 	;CURRENT COMMAND
  D17E                  	EVEN
                        ;
                        ; LBA CONSTANTS
                        ;
  0000                  BOOT_LBA	EQU	0
  0002                  BAT_LBA	EQU	2
  0008                  DIR_LBA	EQU	8
  0010                  FINAL_LBA	EQU	16
  0012                  BLK2_LBA	EQU	18
                        
                        ;
                        ;******************************
                        ;
                        ;	WARM BOOT INTERCEPT
                        ;
                        ;*******************************
                        ;
  D17E   2DC0           BDOS0	RET
  D180   04C0           	CLR	R0			;CLEAR CHANGE AND WRITE FLAGS IN BM
  D182   04E0 D646      	CLR	@BATCHG			;ZERO CAUSES A BATTO BE READ IN
  D186   0460 F028      	B	@MWBOOT			;CALL MONITOR
                        ;
                        ;*******************************
                        ;
                        ;	CONSOLE OUTPUT
                        ;	CHAR IN R3 LSB 
                        ;
                        ;********************************
                        ;
                        ;
  D18A   06C3           COUT	SWPB	R3			;MOVE CHAR TO UPPER MSB FOR MCONOUT
  D18C   D083           	MOVB	R3,R2	 		;CHAR IN MSB OF R2
  D18E   2DA0 F00C      	CALL	@MCONOUT
  D192   2DC0           	RET	
                        ;
                        ;********************************
                        ;
                        ;	CONSOLE INPUT INTO LSB OF R1
                        ;	NOTE ALL OTHER SYSTEMS USE MSB
                        ;
                        ;********************************
                        ;
                        CIN	;MOV	@MON_PTR,R0		;MONITOR ADDRESS
                        	;AI	R0, MCONIN			;ADD THE OFFSET INTO THE MONITOR
  D194   2DA0 F008      	CALL	@MCONIN		;(R0)			;INPUT CHAR IN R1
  D198   06C1           	SWPB	R1
  D19A   2DC0           	RET				;RETURN CHAR IN MSB OF R1
                        ;
                        ;-----------------------------------
                        ;
                        ;  DIRECT CONSOLE IO - BYPASS ANY CHARACTER
                        ;  CHECKING.
                        ;
                        ;  IF R3 = FF00H THEN INPUT A CHAR
                        ;  IF R3 = IS LESS THAN 00FFH THEN OUTPUT THE CHAR IN MSB
                        ;
                        ;-----------------------------------------------------
                        ;
  D19C   D020 D165      DCONIO	MOVB	@ALLONES,R0
  D1A0   9003           	CB	R3,R0
  D1A2   13F8           	JEQ	CIN
  D1A4   10F2           	JMP	COUT
                        ;
                        ;*************************
                        ;
                        ;	SELECT A DISK
                        ;
                        ;*************************
                        ;
  D1A6   C083           DSKFUN	MOV	R3,R2	 		;FOR MONITOR
  D1A8   C803 D166      	MOV	R3,@DISK
  D1AC   0460 F010      	B	@MSELDSK
                        
                        ;
                        ;*************************
                        ;
                        ;	GET CURRENT DISK
                        ;	RETURN IN MSB OF R1
                        ;
                        ;*************************
                        ;
  D1B0   C060 D166      CDFUNC	MOV	@DISK,R1	 		;FOR MONITOR
  D1B4   2DC0           	RET
                        ;
                        ;========================================================================
                        ;
                        ;	BDOS SET THE DMA ADDRESS
                        ;
                        ;=========================================================================
                        ;
                        DMAFUN
  D1B6   C803 D172      	MOV	R3,@WRADDR		;COPY FOR WRSEQ
  D1BA   C803 D174      	MOV	R3,@DMAADDR
  D1BE   2DC0           	RET
                        ;******************************
                        ;
                        ;	MONITOR SET THE DMA ADDRESS IN R2
                        ;
                        ;******************************
                        ;
  D1C0   C802 D174      _SETDMA	MOV	R2,@DMAADDR
  D1C4   2DC0           	RET
                        
                        ;
                        ;=============================================================================
                        ;
                        ; MLOAD - LOAD MODULES USING THE MODULE LOAD TABLE
                        ;
                        ; NOW LOAD THE PROGRAMME's MODULE LOAD TABLE (MLT) (FIRST SECTOR OF ALL NON SYSTEM FILES).
                        ; PROGRAMMES CAN BE MADE UP MULTIPLE MODULES ACROSS MORE THAN A SINGLE MEMORY SEGMENT.
                        ;
                        ;;;;;	CALL	@GETMLT		;LOAD THE FIRST RECORD WHICH IS THE MLT R1 IS CLEAR
                        ;
                        ;
                        ;===============================================================================:
                        ;
  80C0                  MEMBASE:	EQU	80C0H
  D1C6   2DA0 D218      MLOAD:	CALL	@GETMLT
  D1CA   D028 0022      	MOVB	@MPAGE(R8),R0		;THIS IS MEMORY PAGE
  D1CE   D068 0021      	MOVB	@NMSECT(R8),R1		;NUMBER OF RECORDS IN THIS MODULE
  D1D2   C0A8 0010      	MOV	@FLA(R8),R2		;FLA OF ZERO IS DEFAULT. THIS IS THE LOAD ADDRESS FOR THE MODULE
                        
                        ;
                        ; NOW LOAD THE FILE ACCORDING TO THE MODULE TABLE
                        ;
  D1D6   0203 D000      	LI	R3,0D000H		;RETURN FREE MEMORY OR LAST LOAD ADDRESS
  D1DA   2DC0           	RET
                        ;
                        ;--------------------------------------------------------------------------
                        ;
                        ;	OPEN A FILE (FUNCTION 15)
                        ;
                        ;	R3 -> FCB
                        ;
                        ;	THIS FUNCION TRANSFERS ALL THE FILE'S  DIRECTORY DATA
                        ;	TO THE FCB.  IF THE FILE IS NOT FOUND -1 IS RETURNED IN
                        ;	REGISTER R1. NOTE THAT THIS FUNCTION WILL NOT CREATE AN
                        ;	ENTRY IF ONE DOESN'T EXIST. 'MAKEFIL(FUNCTION 22) MUST
                        ;	FIRST BE CALLED, HOWEVER IF 'MAKEFIL' IS CALLED THEN
                        ;	OPEN DOES NOT NEED TO BE CALLED EXPLICITLY IN THIS 
                        ;	INSTANCE.
                        ;
                        ;
                        ;----------------------------------------------------------------------------
                        ;
  D1DC   C203           FOPEN:	MOV	R3,R8		;COPY FCB POINTER FOR INTERNAL USE
  D1DE   2DA0 D374      	CALL	@SEARCH1		;OPEN THE DIRECTORY - GET POINTER IN R3
  D1E2   C041           	MOV	R1,R1		;SUCCESSFUL OPEN ?
  D1E4   1117           	JLT	OPENE
  D1E6   C048           	MOV	R8,R1
  D1E8   C083           	MOV	R3,R2		;DONT TOUCH DIRECTORY POINTER
  D1EA   0221 000B      	AI	R1,NAMSIZ 		;POINT TO FDE
  D1EE   0222 000B      	AI	R2,NAMSIZ		;R2 -> DIRECTORY ENTRY
  D1F2   0200 0015      	LI	R0,DIRSIZ-NAMSIZ	;NO OF BYTES TO TRANSFER
  D1F6   DC72           OPENA:	MOVB	*R2+,*R1+		;TRANSFER ENTRIES
  D1F8   0600           	DEC	R0
  D1FA   16FD           	JNE	OPENA
                        ;
                        ;  'MAKFIL' ENTERS HERE ALSO;
                        ;
                        
  D1FC   04C1           OPENENT:	CLR	R1
  D1FE   CA01 0018       	MOV	R1,@CBN(R8)		;ZERO CURRENT BLOCK FIELD
  D202   CA01 001E      	MOV	R1,@RELR(R8)
  D206   CA01 001C      	MOV	R1,@RELB(R8)
  D20A   CA01 0014      	MOV	R1,@LRBL(R8)
  D20E   CA01 001A      	MOV	R1,@CRN(R8)
                        ;	SETO	@MLBUF		;INVALIDATE MLBUF SO IT IS NOT REUSED FROM A PREVIOUS OPEN
  D212   2DC0           	RET
                        
  D214   0701           OPENE:	SETO	R1
  D216   2DC0           	RET
                        
                        ;=================================================================================
                        ;
                        ;FOR VERSION 4, WE LOAD THE FIRST 512 BYTES INTO MLBUF TO MANAGE THE
                        ;LOCATION TABLE.   THE LOCATION TABLE IS 128 * 4 BYTES LONG OR 512
                        ;THEREFORE THE SECOND SECTOR IS THE FIRST FILE SECTOR.  THE FILE SYSTEM
                        ;DOES NOT NEED TO KNOW ABOUT THIS AS IT JUST MEANS THAT EACH FILE IS 512 BYTES LONGER
                        ;
                        ;ALL FILES, EXCEPT THE SYSTEM FILES HAVE THIS FORMAT.  IT MEANS THAT WHEN A FILE IS CREATED
                        ;AN EMPTY MODULE LOCATION TABLE SECTOR WILL BE ZEROED AND WILL BE THE FIRST SECTOR
                        ;WHICH MEANS THAT IF IT IS ZERO IT IS TREATED AS A NORMAL TPA/LADDR FILE LOAD/SEQUENTIAL READ.
                        ;
                        ;
                        ;CMLTI      NUMBER OF SECTORS   LOAD ADDRESS
                        ;[ 8 bits | ( NMSECT 8 bits)][     16 bits       ]
                        ;[SEG     |   Nx512 sectors ][LOAD ADDRESS OFFSET]
                        ;  0	   12	0X500H
                        ;  1	...etc
                        ;  FF	FF	FFFF	; END OF TABLE
                        ;
                        ;SO BEGIN LOADING AT THE FIRST INDEX.
                        ;THE NEXT INDEX WILL BE USED ONCE THE CRN - NMSECT
                        ;=================================================================================
                        ;
                        ;
                        ; LOAD AND INITIALISE THE LOCATION TABLE INTO MBUF.
                        ; ASSUME R8 HOLDS FCB
                        ;
                        ; CMLTI - THIS IS THE CURRENT MODULE LOAD INDEX.  JUST ONE BYTE I.E UP TO 256 MODULES
                        ; MODS - MODULE SIZE.  THIS IS THE NUMBER OF 512 BYTE RECORDS IN THE PARTICULAR MODULE;
                        ;
                        ; WHICH IN POINTED TO MY CMLTI
                        ;
                        ;
  D218   04C0           GETMLT:	CLR	R0
  D21A   DA00 0020      	MOVB	R0,@CMLTI(R8)		;SET CLMTI TO ZERO
  D21E   0203 DA4A      	LI	R3,MLBUF
  D222   C803 D174      	MOV	R3,@DMAADDR		;SET DMA ADDRESS FOR MLBUF
  D226   C0C8           	MOV	R8,R3		;NEED THE FCB IN R3
  D228   2DA0 D2FA      	CALL	@RDSEQ		;RDSEQ INCREMENTS CRN
                        ;
                        ; NOTE:  IF THE MLI IS ZERO, THAT IS, DEFAULT, THEN SETTING THE PARAMETERS BELOW WILL HAVE NO IMPACT
                        ;
  D22C   0201 DA4A      	LI	R1,MLBUF		;POINT TO THE MODULE INDEX BUFFER
  D230   DA31 0022      	MOVB	*R1+,@MPAGE(R8)		;THIS IS MEMORY PAGE
  D234   DA31 0021      	MOVB	*R1+,@NMSECT(R8)	;NUMBER OF RECORDS IN THIS MODULE
  D238   CA11 0010      	MOV	*R1,@FLA(R8)		;FLA OF ZERO IS DEFAULT. THIS IS THE LOAD ADDRESS FOR THE MODULE
  D23C   04C1           	CLR	R1
  D23E   2DC0           	RET
                        ;
                        ; WE NEED TO ZERO IT AS THIS IS THE DEFAULT FOR A SINGLE MODULE
                        ;
  D240   04C0           MAKEMLT:	CLR	R0
  D242   DA00 0020      	MOVB	R0,@CMLTI(R8)		;SET CLMTI TO ZERO
  D246   0220 0200      	AI	R0, BYTSEC
  D24A   0201 DA4A      	LI	R1,MLBUF
  D24E   04F1           MMLTA	CLR	*R1+		;PAGE = 0, NUMBER OF SECTORS = 0, STARTING ADDRESS = 0
  D250   0600           	DEC	R0
  D252   16FD           	JNE	MMLTA
                        ;
  D254   0200 DA4A      	LI	R0,MLBUF
  D258   C800 D174      	MOV	R0,@DMAADDR		;SET DMA ADDRESS FOR MLBUF
  D25C   C0C8           	MOV	R8,R3		;NEED THE FCB IN R3
  D25E   2DA0 D296      	CALL	@WRSEQ		;RDSEQ INCREMENTS CRN ETC
  D262   2DC0           	RET
                        ;
                        ;
                        ;***************************************************************************
                        ;
                        ;	CLOSE A	FILE (FUNCTION 16)
                        ;
                        ;	R3 -> FCB
                        ;
                        ;	SIMILAR TO OPEN FUNCTION EXCEPT THAT THE FILE SHOULD 
                        ;	HAVE BEEN PREVIOUSLY EITHER OPENED USING 'OPEN' OR
                        ;	CREATED USING 'MAKFIL'. ANY OTHER METHOD OF CALLING
                        ;	WILL TRANSFER JUNK TO THE DIRECTORY - NOT A PLEASANT 
                        ;	THOUGHT.
                        ;
                        ;	CLOSE ALSO ZERO'S THE CRN & CBN WORDS SO THAT OPEN DOES
                        ;	NOT HAVE TO INITIALISE THESE TWO VALUES.
                        ;
                        ;*****************************************************************************
                        ;
  D264   4643 4C4F      DB_FCLOSE:	TEXT	"FCLOSE"
  D268   5345           
  D26A   00             	BYTE	0
  D26B   00             	EVEN
                        
  D26C   C203           FCLOSE:	MOV	R3,R8		;COPY FCB POINTER
  D26E   2DA0 D374      	CALL	@SEARCH1 		;MAKE SURE THE FILE EXISTS AND OPEN THE DIRECTORY
  D272   C041           	MOV	R1,R1	 	;ERROR ?
  D274   110F           	JLT	CLOSEB	 	;YES
  D276   C048           	MOV	R8,R1		;FCB POINTER
  D278   C083           	MOV	R3,R2		;DONT TOUCH R3
  D27A   0221 000B      	AI	R1,NAMSIZ		;ENTRY DATA POINTER
  D27E   0222 000B      	AI	R2,NAMSIZ		;DIR ENTRY POINTER
  D282   0200 0015      	LI	R0,DIRSIZ-NAMSIZ		
  D286   DCB1           FCLOSE1:	MOVB	*R1+,*R2+		;UPDATE DIRECTORY ENTRY
  D288   0600           	DEC	R0
  D28A   16FD           	JNE	FCLOSE1
                        ;	
                        ; UPDATE DIRECTORY ENTRY
                        ;
                        ;	DEBUG	@DB_FCLOSE
                        ;	BLWP	@MONITOR
                        
                        ;	CALL	@WRREC	 	;ALL POINTERS ARE UNTOUCHED FROM SEARCH1
  D28C   2DA0 D624      	CALL	@WRDIR		;UPDATE THE DIRECTORY ENTRY
  D290   2DA0 D48C      	CALL	@RECLAIM		;TRY TO RECLAIM UNUSED BLOCKS	
  D294   2DC0           CLOSEB	RET
                        ;
                        ;***************************************************
                        ;
                        ;	WRITE SEQUENTIALLY (FUNCTION 21)
                        ;	CALL TO SETDMA BEFORE CALLING THIS FUNCTION
                        ;	R3 -> FCB
                        ;
                        ;	THIS FUNCTION IS CONTROLLED MAINLY BY 
                        ;	THE CRN (NEXT RECORD TO READ) COUNTER.
                        ;
                        ;	FOR VERSION 4 AND THE INTRODUCTION OF MODULES BDOS NEEDS TO FIRST
                        ;	CREATE THE MODULE LOAD HEADER IF THIS THE FIRST WRITE TO AN OPEN FILE.
                        ;
                        ;
                        ;
                        ;*****************************************************
                        ;
                        
  D296   C203           WRSEQ:	MOV	R3,R8		;SAVE FCB POINTER
  D298   2DA0 D526      	CALL	@CRNTBC	 	;CRN TO RELATIVE BLOCK & REMAINDER
  D29C   C803 D16C      	MOV	R3,@CBO		;SAVE OFFSET
                        ;
                        ;	IF WE COULD TRACE FROM EXISTING POSITION WE COULD SPEED THINGS UP AND STOP THRASHING
                        ;	TRACE1 WILL USE CRN
                        ;
  D2A0   C0C2           	MOV	R2,R3		;R3 NOW HOLDS RELATIVE BLOCK NUMBER
  D2A2   2DA0 D578      	CALL	@TRACE
  D2A6   8081           	C	R1,R2		;IF ALLOCATED CONTINUE
  D2A8   1316           	JEQ	WRSEQ0
                        ;
                        ;	AT THIS POINT WE HAVE THE CBP FROM TRACE
                        ;	NXTBLK WILL FIND A BLOCK AND ALLOCATE IT (LINK) 
                        ;	BASED ON CBP
                        ;
  D2AA   2DA0 D534      	CALL	@NXTBLK	 	;LOCATE A BLOCK AND RETURN IN R7
  D2AE   C041           	MOV	R1,R1		;ANY BLOCKS LEFT ?
  D2B0   1123           	JLT	WRSEQ2		;NO - SHOW ERROR
                        ;
                        ;	IN CASE WE CROSS BAT BOUNDARIES WE NEED TO ALLOCATE LAST BLOCK FIRST
                        ;	AND THEN POSTFIX THE CAB FOUND IN TRACE.  TRACE HAS FILLED THE CBP AND
                        ;	CAB WHICH NEED TO BE UPDATED. R7 IS THE CURRENT BLOCK POINTER AND
                        ;	R6 CONTAINS THE FREE BLOCK NUMBER
                        ;
  D2B2   0201 FF80      	LI	R1,LASTBLK		;ALLOCATE THIS BLOCK TO THIS FILE
  D2B6   C5C1           	MOV	R1,*R7		;NEW END OF LINK IN CURRENT BAT FROM NXTBLK
  D2B8   C807 D16A      	MOV	R7,@CBP		;AND KEEP CBP UPDATED
  D2BC   0720 D646      	SETO	@BATCHG		;FORCE AN UPDATE TO THE BAT
                        ;
                        ;	NOW UPDATE PREVIOUS LAST BLOCK TO POINT NOW TO THE NEW LAST BLOCK
                        ;
  D2C0   2E06           	PUSH	R6		;PUSH NEW ALLOCATED BLOCK CAB
  D2C2   C0E0 D168      	MOV	@CAB,R3		;GET PREVIOUS LAST BLOCK RETURNED FROM TRACE
  D2C6   2DA0 D5A4      	CALL	@GETBATP		;FIND THE BAT AND GET THE POINTER FROM THE INDEX
  D2CA   2E46           	POP	R6
  D2CC   C5C6           	MOV	R6,*R7		;UPDATE TO NEW END OF LINK
  D2CE   C806 D168      	MOV	R6,@CAB		;UPDATED FROM NXTBLK
  D2D2   0720 D646      	SETO	@BATCHG		;FORCE AN UPDATE TO THE BAT
                        ;	
  D2D6   C0A0 D168      WRSEQ0	MOV	@CAB,R2		;RECOVER DISK BLOCK
  D2DA   C0E0 D16C      	MOV	@CBO,R3		;AND OFFSET
  D2DE   0200 0002      	LI	R0,WRCMD
  D2E2   C800 D17C      	MOV	R0,@CCMD		;CURRENT COMMAND
                        
  D2E6   2DA0 D354      	CALL	@RWREC
  D2EA   C041           	MOV	R1,R1		;WAS THERE AN ERROR
  D2EC   1105           	JLT	WRSEQ2		;JUMP IF YES
                        
  D2EE   05A8 000E      	INC	@FSZ(R8) 		;BUMP THE SECTOR COUNT
  D2F2   05A8 001A      	INC	@CRN(R8) 		;BUMP CURRENT RECORD
                        
  D2F6   04C1           WRSEQ1	CLR	R1
  D2F8   2DC0           WRSEQ2	RET
                        
                        ;
                        ;=====================================================================================
                        ;	READ SEQUENTIALLY
                        ;	R3 -> FCB
                        ;	ASSUME THE CALL TO DMAFUNC HAS BEEN MADE SO WE CAN
                        ;	SAFELY SET THE PAGE INDEX IF NECESSARY USING FCB IN R3
                        ;
                        ;=================================================================================
                        ;
  D2FA   C203           RDSEQ:	MOV	R3,R8		;COPY FCB ADDRESS OF FCB
  D2FC   8A28 001A      	C	@CRN(R8),@FSZ(R8)	;END OF FILE ?
  D300   000E           
  D302   1414           	JHE	RDSEQ1		;YES
  D304   2DA0 D526      	CALL	@CRNTBC		;CONVERT CRN TO A RELATIVE BLOCK NUMBER
  D308   C803 D16C      	MOV	R3,@CBO		;SAVE OFFSET AND USE BLOCK IN R2 TO
  D30C   2DA0 D578      	CALL	@TRACE		;TRACE THROUGH THE LINKED ALLOCATION LIST
  D310   C0E0 D16C      	MOV	@CBO,R3		;RECOVER VARIABLES FOR RWREC
  D314   C0A0 D168      	MOV	@CAB,R2
  D318   0200 0001      	LI	R0,RDCMD
  D31C   C800 D17C      	MOV	R0,@CCMD		;CURRENT COMMAND
                        ;
                        ; R8 HOLDS FCB
                        ;
  D320   2DA0 D354      	CALL	@RWREC
  D324   05A8 001A      	INC	@CRN(R8)		;BUMP TO NEXT RECORD 
  D328   04C1           	CLR	R1
  D32A   2DC0           	RET
                        ;
  D32C   0701           RDSEQ1	SETO	R1
  D32E   2DC0           	RET
                        ;
                        ;*******************************
                        ;
                        ;	R3 -> FCB
                        ;	READ RANDOM RECORD
                        ;
                        ;********************************
                        ;
  D330   C8E3 001C      RDRND:	MOV	@RELB(R3),@CBN(R3)	;TRANSER RECORD NUMBER
  D334   0018           
  D336   C8E3 001E      	MOV	@RELR(R3),@CRN(R3)
  D33A   001A           
  D33C   2DA0 D2FA      	CALL	@RDSEQ
  D340   0628 001A      	DEC	@CRN(R8)		;READ RANDOM CAN'T INCREMENT THE CRN
  D344   2DC0           	RET
                        ;
                        ;*******************************
                        ;
                        ;	WRITE RANDOM RECORD
                        ;	R3 -> FCB
                        ;	(R3)RELR  MUST HOLD THE RECORD TO WRITE TO
                        ;
                        ;*******************************
                        ;
  D346   C8E3 001C      WRRND:	MOV	@RELB(R3),@CBN(R3)	;TRANSEFER RECORD NUMBER
  D34A   0018           
  D34C   C8E3 001E      	MOV	@RELR(R3),@CRN(R3)
  D350   001A           
  D352   10A1           	JMP	WRSEQ		;NORMAL SEQUENTIAL WRITE
                        ;
                        ;*******************************
                        ;
                        ;	COMMON READ WRITE ENTRY
                        ;
                        ;	R8 --> FCB
                        ;	R2 = CURRENT BLOCK NUMBER (ID)
                        ;	R3 = CURRENT BLOCK OFFSET
                        ;*******************************
                        ;
                        ;DB_RWREC	TEXT	"RWREC"
                        ;	BYTE	0
                        ;	EVEN
  D354   0A22           RWREC:	SLA	R2,2		;THERE ARE 4 SECTORS PER BLOCK
  D356   A0C2           	A	R2,R3		;WE NOW HAVE THE BASE LBA
  D358   0A13           	SLA	R3,1		;BECAUSE WE HAVE TO READ TWO LBA FOR AN EFFECTIVE 512 BYTES
  D35A   C0A0 D172      	MOV	@WRADDR,R2		;THIS IS THE LOCAL COPY OF DMA ADDR
  D35E   2DA0 D1C0      	CALL	@_SETDMA		;CAUGHT WITH CALLS THROUGH DMAFUN VALUE IN R4 FOR MONITOR
  D362   C020 D17C      	MOV	@CCMD,R0		;GET TYPE
  D366   0280 0002      	CI	R0,WRCMD		;READ ? 
                        ;	DEBUG	@DB_RWREC
  D36A   1602           	JNE	RWREC_R	 	;TRY FOR WRITE
  D36C   0460 D566      	B	@WRREC	 	;RETURN FROM RDREC
  D370   0460 D554      RWREC_R:	B	@RDREC	 	;ASSSUME READ
                        ;
                        ;
                        ;***************************************************************
                        ;
                        ;	SEARCH FIRST( LOOK FOR DIRECTORY ENTRY)
                        ;
                        ;	NORMAL DIRECTORY SEARCH BEGINNING AT THE
                        ;	START OF THE DIRECTORY CONTINUING TILL END.
                        ;
                        ;	E5 => DELETED ENTRY	
                        ;	00 => END OF DIRECTORY	
                        ;	R3 -> FCB	
                        ;
                        ;	RETURN 
                        ;		R1 =  MINUS ONE FOR BAD RESULT 
                        ;		R3 -> CURRENT DIRECTORY ENTRY
                        ;
                        ;***************************************************************
                        ;
  D374   C203           SEARCH1:	MOV	R3,R8		;SAVE FCB FOR DIROPN
  D376   0720 D170      	SETO	@DIRENT		;SET CURRENT SECTOR DIRECTORY INDEX
  D37A   04E0 D17A      	CLR	@CDSECT		;BEGIN SEARCHING AT FIRST SECTOR
  D37E   2DA0 D4CC      	CALL	@DIROPN	 	;OPEN THE DIRECTORY
  D382   1014           	JMP	DLOOK		;RETURN FROM DLOOK
                        ;
                        ;***************************************************************
                        ;
                        ;	SEARCH NEXT (SEARCH2)
                        ;
                        ;	SIMILAR TO CPM - BASICALLY CONTINUES
                        ;	WHERE LAST SEARCH LEFT OFF. THAT IS IT 
                        ;	SIMPLY DOES NOT ALTER THE VALUE OF THE 
                        ;	DIRENT AND CDSECT VARIABLES.
                        ;
                        ;**************************************************************
                        ;
  D384   C203           SEARCH2:	MOV	R3,R8
  D386   2DA0 D4CC      	CALL	@DIROPN		;OPEN THE DIRECTORY
  D38A   1010           	JMP	DLOOK
                        ;
                        ;-------------------------------------------------
                        ;
                        ;  FUCTION 35 - GET FILE SIZE
                        ;
                        ;   R2 = FUNCTION NUMBER
                        ;   R3 -> FCB
                        ;
                        ;   PURPOSE - MOVE THE ADDRESS OF THE LAST RECORD
                        ;	      TO THE RELATIVE FIELDS
                        ;
                        ;-------------------------------------------------
                        ;
  D38C   C203           GETSIZ:	MOV	R3,R8		;COPY FCB POINTER FOR INTERNAL USE
  D38E   2DA0 D374      	CALL	@SEARCH1		;OPEN THE DIRECTORY
  D392   C041           	MOV	R1,R1		;SUCCESSFUL OPEN ?
  D394   1103           	JLT	GETSIZ1	
  D396   CA28 000E      	MOV	@FSZ(R8),@RELR(R8)	;TRANSFER THE FILE SIZE
  D39A   001E           
  D39C   2DC0           GETSIZ1:	RET
                        ;
                        ;--------------------------------------------------
                        ;
                        ;	FUCTION 36 - SET RELATIVE RECORD
                        ;	R2 =  FUNCTION NUMBER
                        ;	R3 -> FCB
                        ;
                        ;	PURPOSE - THE RELATIVE RECORD FIELD IS SET TO THE
                        ;	SAME FILE ADDRESS AS THE CURRENT BLOCK AND
                        ;	CURRENT RECORD.
                        ;
                        ;---------------------------------------------------
                        ;
  D39E   C8E3 0018      SETREL:	MOV	@CBN(R3),@RELB(R3)	;TRANSFER RECORD POINTERS
  D3A2   001C           
  D3A4   C8E3 001A      	MOV	@CRN(R3),@RELR(R3)
  D3A8   001E           
  D3AA   2DC0           	RET
                        ;
                        ;*****************************************
                        ;
                        ;	GENERAL DIRECTORY SEARCH SUBROUTINE
                        ;	R8 = PTR TO FCB
                        ;	MUST CHECK FILE ATTRIBUTES FOR FILE TYPE
                        ;
                        ;******************************************
                        ;
  D3AC   2DA0 D4EE      DLOOK:	CALL	@DIRBLK	 	;GET NEXT ENTRY PNTR IN R3
  D3B0   1115           	JLT	NONTRY	 	;NOT FOUND
  D3B2   C083           DLOOK1	MOV	R3,R2	 	;SAVE PNTR
  D3B4   D012           	MOVB	*R2,R0	 	;TEST FOR EOD
  D3B6   11FA           	JLT	DLOOK	 	;DELETED ENTRY
  D3B8   1502           	JGT	DLOOK4	 	;VALID
  D3BA   04C3           	CLR	R3	 	;SHOW END OF DIRECTORY REACHED
  D3BC   100F           	JMP	NONTRY	
  D3BE   0200 000B      DLOOK4	LI	R0,NAMSIZ 		;NUMBER OF CHARS TO MATCH
  D3C2   C148           	MOV	R8,R5		;SAVE FCB PNTR
  D3C4   9815 D164      NXTLTR	CB	*R5,@WILD		;? WILL MATCH ALL (LIKE CPM)
  D3C8   1603           	JNE	DLOOK5		;PROCESS NORMALLY
  D3CA   0585           	INC	R5		;ELSE ASSUME MATCH SO BUMP POINTERS
  D3CC   0582           	INC	R2
  D3CE   1002           	JMP	DLOOK6
  D3D0   9D72           DLOOK5	CB	*R2+,*R5+		;MATCH ?
  D3D2   16EC           	JNE	DLOOK	 	;NO SO - KEEP LOOKING
  D3D4   0600           DLOOK6	DEC	R0	
  D3D6   16F6           	JNE	NXTLTR	 	;CONTINUE
  D3D8   04C1           	CLR	R1	 	;SHOW GOOD RESULT
  D3DA   2DC0           	RET	
  D3DC   0701           NONTRY	SETO	R1	 
  D3DE   2DC0           	RET			;SHOW NOT FOUND
                        ;
                        ;********************************	
                        ;
                        ;	CREATE A DIRECTORY ENTRY (FUNCTION 22)
                        ;
                        ;	ENTRY: 	R3 -> FCB
                        ;		R2 = 22
                        ;
                        ;	RETURN:	R1 = 0 EMPTY DIRECTORY FOUND
                        ;		R1 = FF NO EMPTY DIRECTORY AVAILABLE
                        ;
                        ;	THIS FUNCTION SHOULD BE CALLED ONLY WITH THE
                        ;	FILENAME IN THE FIRST 10 BYTES OF THE FCB. 'MAKFIL'
                        ;	MAKES A POINT OF ZEROING ALL BAR THE FILENAME WITH
                        ;	THE DIRECTORY ENTRY BEFORE WRITING IT TO DISK. HENCE
                        ;	YOU MUST CALL CLOSE TO PROPERLY TRANSFER ANY FILE 
                        ;	ATTRIBUTES ETC. ALSO NOTE THAT THE FSB WILL BE RETURNED
                        ;	HOWEVER ALL OTHER FCB ENTRIES WILL BE ZEROED.
                        ;
                        ;
                        ;******************************	
                        ;
                        ;IDE_MODIFICTION_IN PROGRESS
                        ;DB_MAKF1:	TEXT	"MAKFL1"	;TEMP FOR DEBUG
                        ;	WORD	0
                        ;	EVEN
                        
  D3E0   C203           MAKFIL:	MOV	R3,R8			;LOCAL FCB COPY
  D3E2   2DA0 D534      	CALL	@NXTBLK	 		;FIND A SECTOR FOR FSB AND PLACE IN CAB
  D3E6   C041           	MOV	R1,R1	 		;ERROR ?
  D3E8   112E           	JLT	MAKERR			;LOOKS LIKE DISK FULL 
  D3EA   C806 D168       	MOV	R6,@CAB			;UPDATE BLOCK NUMBER AND
  D3EE   C807 D16A      	MOV	R7,@CBP			;POINTER TO THE CURRENT BLOCK
                        
  D3F2   0720 D170      	SETO	@DIRENT			;SIMILAR TO SEARCH1
  D3F6   04E0 D17A      	CLR	@CDSECT			;MUST SET THESE VARIABLES
  D3FA   2DA0 D4CC      	CALL	@DIROPN	 		;OPEN THE DIRECTORY
  D3FE   2DA0 D4EE      NTHR	CALL	@DIRBLK	 		;GET ENTRY THROUGH R3
  D402   1121           	JLT	MAKERR			;END OF DIRECTORY
  D404   D013           	MOVB	*R3,R0	 		;CHECK ENTRY
  D406   15FB           	JGT	NTHR	 		;VALID ENTRY
                        ;
                        ; ASSUME R3 NOW POINTS TO DIR ENTRY AND R6 HOLDS THE LBA
                        ;
  D408   04C0           	CLR	R0
  D40A   C148           	MOV	R8,R5		;R8 HOLDS THE FCB
  D40C   0225 000B      	AI	R5,FTY		;FLUSH FROM FILE TYPE ENTRY
  D410   0202 0015      	LI	R2,DIRSIZ-NAMSIZ	;NUMBER OF BYTES TO ZERO
  D414   DD40           MKFIL2	MOVB	R0,*R5+
  D416   0602           	DEC	R2
  D418   16FD           	JNE	MKFIL2
  D41A   CA20 D168      	MOV	@CAB,@FSB(R8)		;TRANSFER FSB
  D41E   000C           
  D420   0201 FF80      	LI	R1,LASTBLK		;MARK AS FIRST AND LAST BLOCK IN BAT
  D424   C020 D16A      	MOV	@CBP,R0
  D428   C401           	MOV	R1,*R0		;SHOW ITS THE LAST BLOCK AS WELL AS THE FIRST
                        ;
                        ; NOW CREATE THE ZERO LENGTH FILE
                        ;
                        ;	MOV	R3,@DMAADDR
  D42A   0202 0020      	LI	R2,DIRSIZ		;TRANSFER FILENAME + FSB TO DIRECTORY
  D42E   C148           	MOV	R8,R5	 	;SAVE FCB VECTOR
  D430   DCF5           MKFIL1	MOVB	*R5+,*R3+		;TRANSER FCB ENTRY TO DIRECTRY RECORD
  D432   0602           	DEC	R2
  D434   16FD           	JNE	MKFIL1
                        ;
                        ;
                        ; CALL WRDIR TO WRITE OUT THE DISC DIRECTORY ENTRY AND THEN UPDATE THE BAT;
                        ; R8 ->  FCB
                        ;
  D436   2DA0 D624      	CALL	@WRDIR
  D43A   2DA0 D5FE      	CALL	@WRBAT	 	;UPDATE BAT AS DIRECTORY ENTRY IS VALID
  D43E   C041           	MOV	R1,R1		;IF NO ERROR SIMULATE 'OPEN'
  D440   1102           	JLT	MAKERR
  D442   0460 D1FC      	B	@OPENENT
  D446   0701           MAKERR	SETO	R1 
  D448   2DC0           	RET
                        ;
                        ;*************************************************
                        ;
                        ;  RENAME A FILE
                        ;
                        ;  R3 -> FCB
                        ;  BYTES 0 - 17  OLD NAME
                        ;  BYTES 18- 27  NEW NAME
                        ;
                        ;*************************************************
                        ;
  D44A   C203           RENAME:	MOV	R3,R8
  D44C   2DA0 D374      	CALL	@SEARCH1		;CHECK TO SEE IF THE FILE EXITS
  D450   C041           	MOV	R1,R1
  D452   110B           	JLT	RENAM2		;NOT FOUND
  D454   0200 000B      	LI	R0,NAMSIZ		;FILENAME SIZE	
  D458   C083           	MOV	R3,R2		;R2 -> DIRECTORY ENTRY
  D45A   C048           	MOV	R8,R1
  D45C   0221 0012      	AI	R1,NAMEOFF2		;POINT TO 2ND FILE NAME
  D460   DCB1           RENAM1	MOVB	*R1+,*R2+		;COPY NEW FILE NAME OVER OLD ONE
  D462   0600           	DEC	R0
  D464   16FD           	JNE	RENAM1		;JUMP IF NOT DONE
                        ;
                        ; NOW WRITE THE NEW DIRECTORY ENTRY BACK
                        ;
  D466   2DA0 D624      	CALL	@WRDIR		;ALL DIRECTORY POINTERS UNTOUCHED FROM SEARCH1
  D46A   2DC0           RENAM2	RET
                        ;
                        ;******************************
                        ;
                        ;	ERASE A	DIRECTORY ENTRY
                        ;
                        ;	R3 -> FCB
                        ;
                        ;	ON RETURN R1 = 0 FOR DIRECTORY ENTRY FOUND
                        ;		     = -1 FOR NO DIRECTORY ENTRY FOUND
                        ;
                        ;*******************************
                        ;
  D46C   C203           ERAFIL:	MOV	R3,R8
  D46E   2DA0 D374      	CALL	@SEARCH1 		;LOOK FOR THE FILE ENTRY
  D472   C041           	MOV	R1,R1	 	;DID WE FIND IT ?
  D474   1129           	JLT	ERAERR	 	;NO
  D476   0201 8000      	LI	R1,8000H		;R3->DIR ENTRY
  D47A   F8C1 0000      	SOCB	R1,@NAM(R3)		;MAKE DELETED
  D47E   CA23 000C      	MOV	@FSB(R3),@FSB(R8)	;NB RECOVER BAT POINTER
  D482   000C           
  D484   04E8 000E      	CLR	@FSZ(R8)		;FORCE RE-ALLOCATION OF USED BLOCK
  D488   2DA0 D624      	CALL	@WRDIR	 	;WRITE FDE BACK TO DISK
                        ;
                        ;---NOW RELEASE	ALLOCATED BLOCKS
                        ;
  D48C   04C3           RECLAIM:	CLR	R3		;START AT FIRST BAT SECTOR
  D48E   2DA0 D5A4      	CALL	@GETBATP 		;READ IN THE BAT TABLE
  D492   C0E8 000E      	MOV	@FSZ(R8),R3		;GET FILE SIZE FOR AND
  D496   2DA0 D52A      	CALL	@RECTBC		;CONVERT FILE SIZE TO BLOCKS
  D49A   2DA0 D578      	CALL	@TRACE		;TRACE THROUGH TO TO BLOCK NUMBER
  D49E   0201 FF80      	LI	R1,LASTBLK
  D4A2   C0D7           	MOV	*R7,R3		;RECOVER BAT INDEX
  D4A4   C5C1           	MOV	R1,*R7		;ASSUME LAST LINK ENTRY
  D4A6   C028 000E      	MOV	@FSZ(R8),R0		;ZERO FILE SIZE IE RECLAIM ALL BLOCKS?
  D4AA   1601           	JNE	ERA00		;NO
  D4AC   04D7           	CLR	*R7		;YES SO ZERO LAST LINK
  D4AE   8043           ERA00	C	R3,R1		;LAST LINK ?
  D4B0   1307           	JEQ	ERA02		;YES
  D4B2   2DA0 D5A4      ERA01	CALL	@GETBATP		;GET INDEX (IN R5) TO NEXT BAT
  D4B6   C0D7           	MOV	*R7,R3 		;NEXT INDEX VALUE
  D4B8   04D7           	CLR	*R7		;ZERO TO SHOW BLOCK IS FREE
  D4BA   8043           	C	R3,R1		;CHECK FOR FINAL LINK
  D4BC   1301           	JEQ	ERA02		;YES - SO WE'RE FINISHED
  D4BE   10F9           	JMP	ERA01		;KEEP GOING
  D4C0   2DA0 D5FE      ERA02	CALL	@WRBAT		;UPDATE DISK VERSION OF BAT
  D4C4   04C1           	CLR	R1		;DONE
  D4C6   2DC0           	RET	
  D4C8   0701           ERAERR	SETO	R1
  D4CA   2DC0           	RET
                        ;
                        ;*********************************
                        ;
                        ;	READ IN THE DIRECTORY
                        ;
                        ;	ENTER WITH  R8 -> FCB
                        ;
                        ;
                        ;*********************************
  D4CC   C0E0 D17A      DIROPN:	MOV	@CDSECT,R3		;ASSUME CURRENT DIRECTORY SECTPR THIS HAS BEEN SET
  D4D0   0200 0008      	LI	R0,DIR_LBA		;GET FIRST DIRECTORY LBA
  D4D4   0A13           	SLA	R3,1		;2 LBAS PER SECTOR
  D4D6   A0C0           	A	R0,R3		;R3 HOLDS THE LBA
  D4D8   C803 D178      	MOV	R3,@LBA+2		;SET THE SECTOR TO READ
  D4DC   0202 D84A      	LI	R2,DIRBUFF 		;BUFFER TO USE
  D4E0   2DA0 D1C0      	CALL	@_SETDMA	 	;BIOS DMA
  D4E4   2DA0 D554      	CALL	@RDREC	 	;READ IN DIRECTORY
  D4E8   0203 D84A      	LI	R3,DIRBUFF		;USE SAME BUFFER 
  D4EC   2DC0           	RET
                        ;
                        ;
                        ;==============================================================
                        ;	FIND THE NEXT DIRECTORY ENTRY
                        ;	DIRENT IS JUST AN OFFSET INTO THE 
                        ;	DIRECTORY BUFFER. ITS VALUUE DEPENDS ON 
                        ;	THE BLOCK SIZE.
                        ;
                        ;	R3 -> TO FILE DIRECTORY CONTENTS
                        ;===============================================================
                        ;
  D4EE   05A0 D170      DIRBLK:	INC	@DIRENT	 	;UP THE LAST ENTRY, INITIALISED TO -1
  D4F2   C0E0 D170      	MOV	@DIRENT,R3
  D4F6   0A53           	SLA	R3,5		;*32 IE 32 BYTES DIRECTORY ENTRY
  D4F8   0223 D84A      	AI	R3,DIRBUFF		;POINT TO NEXT ENTRY
  D4FC   0283 DA4A      	CI	R3,DIRBUFF+BUFSIZ	;HAVE WE REACHED THE END OF THE BUFFER
  D500   1A0D           	JL	DIRB01		;NO
  D502   05A0 D17A      	INC	@CDSECT	 	;NOW - TRY NEXT SECTOR
  D506   C0E0 D17A      	MOV	@CDSECT,R3		;R3 HOLDS RECORD OFFSET WITHIN BLOCK
  D50A   0283 0004      	CI	R3,NDSECT		;NUMBER OF SECTORS ALLOCATED TO DIRECTORY
  D50E   1409           	JHE	DIRB03		;SHOW END OF DIRECTORY
  D510   2DA0 D4CC      	CALL	@DIROPN		;READ THE DIRECTORY
                        ;
                        ;SHOULD THIS BE SET TO ONE OR CLR'D?
                        ;	CLR	@DIRENT		;RESET FOR NEXT TIME
  D514   0720 D170      	SETO	@DIRENT		;RESET FOR NEXT TIME
  D518   0203 D84A      	LI	R3,DIRBUFF		;-->DIRECTORY ENTRY
  D51C   04C1           DIRB01:	CLR	R1		;FLAG SET
  D51E   C041           DIRB02:	MOV	R1,R1	 	;SET STATUS
  D520   2DC0           	RET
  D522   0701           DIRB03:	SETO	R1
  D524   10FC           	JMP	DIRB02
                        ;
                        ;******************************
                        ;
                        ;	CONVERT CRN TO BLOCK NUMBER (CRNTBC)
                        ;
                        ;	THIS ROUTINE SIMPLY DIVIDES RECORD NUMBER
                        ;	BY BLOCK SIZE TO GIVE A RELATIVE BLOCK NO
                        ;	SO THAT THE BAT MAY BE INDEXED VIA RESULT
                        ;	IN R2.
                        ;
                        ;*******************************
                        ;
  D526   C0E8 001A      CRNTBC:	MOV	@CRN(R8),R3 	;NEXT RECORD TO READ
                        ;
                        ;	ENTER HERE IF GENERAL RELATIVE CONVERSION REQUIRED
                        ;	R3 MUST HOLD RECORD NUMBER - NOTE RELATIVE OFFSET WITHIN BLOCK IS FOUND
                        ;	RECORDS BEGIN AT 1
                        ;	BLOCKS BEGIN AT 0
                        ;
  D52A   04C2           RECTBC	CLR	R2	 	;FOR DIVIDE
  D52C   0200 0004      	LI	R0,SECBLK	 	;SECTORS/BLOCK
  D530   3C80           	DIV	R0,R2	 	;R2 & R3 HOLD RESULT
  D532   2DC0           RECTBC1	RET
                        ;
                        ;------------------------------------------------------------------------
                        ;
                        ;	BLOCK NO. TO TRK/SECT CONVERSION
                        ;
                        ;	THIS ROUTINE WILL CONVERT A GIVEN BLOCK AND
                        ;	AND RECORD NUMBER WITHIN A FILE TO A PHYSICAL
                        ;	TRACK AND SECTOR. I.E. YOU MAY WISH TO LOCATE
                        ;	THE TRACK/SECTOR OF SAY RECORD 3 WITHIN BLOCK
                        ;	10 ETC.
                        ;
                        ;	THIS ROUTINE IS NORMALLY CALLED AFTER A CALL
                        ;	TO CRNTBC/RECTBC WITHIN RDSEQ ,WRSEQ ETC.
                        ;
                        ;	R1 = BLOCK NO.
                        ;	R3 = RECORD OFFSET WITHIN BLOCK
                        ;
                        ;	RECORDS BEGIN AT 1
                        ;	BLOCKS BEGIN AT 0
                        ;
                        ;	RETURN WITH R2=TRACK,R3=SECTOR
                        ;
                        ;	TRK = INT((BLK*SECBLK + R3)/SECTRK)
                        ;	SECT = REMAINDER(BLK...)+1		
                        ;
                        ;	R2 = TRK, R3 = SECT
                        ;
                        ; NOTE NEEDED TO REMOVE THE MULTIPY AS IT HAS A BUG.  SEE 99105 ERRATA
                        ;------------------------------------------------------------------------
                        ;
                        ;REVISED MULTIPLY TO AVOID 99105 MULTIPLY BUG
                        ;
                        
                        ;BTTSC	LI	R0,SECBLK
                        ;	CLR	R2
                        ;	JEQ	BTTSC2
                        ;BTTSC1	A	R1,R2		;R2=BLK*SECBLK
                        ;	DEC	R0
                        ;	JNE	BTTSC1
                        ;BTTSC2	A	R2,R3		;R3=BLK*SECBLK+R3
                        ;	CLR	R2		;MSB OF QUOTIENT
                        ;	LI	R0,SECTRK		;SECTORS/TRACK
                        ;	DIV	R0,R2	 	;R2=TRK,R3=SECT (R2+R3)/R0
                        ;	INC	R3		;TAKES CARE OF ZERO OFFSET FOR CRN
                        ;BTTSC0	RET
                        ;
                        ;*******************************
                        ;
                        ;	
                        ;	FIND A FREE BLOCK	
                        ;	NXTBLK WILL TRAVERSE THE BAT LOOKING FOR A ZEROED
                        ;	BAT ENTRY.  ONCE FOUND NO CHANGE TO THE BAT WILL BE
                        ;	MADE AND ONLY THE POINTERS TO THE ENTRY WILL BE RETURNED.
                        ;	IT IS THEN UP TO THE CALLING PROGRAMME TO INSERT THE NEW
                        ;	LINKS.
                        ;
                        ;	NOTE: RDBAT WILL PULL IN THE APPROPRIATE BAT SECTOR AS REQUIRED
                        ;
                        ;	R8 -> FCB
                        ;
                        ;	R1 = -1 (ERROR)
                        ;	R1 = 0  (GOOD RESULT)
                        ;	
                        ;
                        ;****************************************************************
                        ;
  D534   C020 D168      NXTBLK:	MOV	@CAB,R0			;BEGIN AT LAST BLOCK TO SPEED THINGS UP AND TO STOP THRASHING
                        
  D538   C0C0           NXTBLK2	MOV	R0,R3
  D53A   2DA0 D5A4      	CALL	@GETBATP			;FIND THE BAT AND GET THE POINTER FROM THE INDEX
                        
  D53E   C057           	MOV	*R7,R1			;POINTER IS IN R7
  D540   1305           	JEQ	NXTBLK4			;ANY FREE ? YES
  D542   0281 FFFF      	CI	R1,-1			;LAST AVAILABLE BLOCK ?
  D546   1304           	JEQ	NXTBLK3			;YES
  D548   0580           	INC	R0			;NEXT BLOCK
  D54A   10F6           	JMP	NXTBLK2			;KEEP LOOKING
                        ;
                        ; R7 -> FREE BLOCK
                        ; R6 =  FREE BLOCK NUMBER
                        ;
  D54C   C180           NXTBLK4	MOV	R0,R6			;COPY FREE BLOCK NUMBER HERE
  D54E   04C1           	CLR	R1			;SHOW SUCCESS
  D550   C041           NXTBLK3	MOV	R1,R1			;RETURN WITH RESULT CONDINTION SET
  D552   2DC0           	RET 
                        ;
                        ;****************************
                        ;
                        ;	READ A RANDOM RECORD
                        ;	R8 -> FCB
                        ;	R3 -> LBA
                        ;
                        ;******************************
                        
  D554   C120 D174      RDREC:	MOV	@DMAADDR,R4
  D558   2DA0 F01C      	CALL	@MRDREC	 	;READ THE RECORD IN
                        ;	CLR	R1
  D55C   C041           	MOV	R1,R1	 	;ERROR ?
  D55E   1301           	JEQ	RDREC1	 	;NO
  D560   0701           RDERR	SETO	R1	 	;SHOW ERROR
  D562   C041           RDREC1	MOV	R1,R1
  D564   2DC0           	RET
                        ;
                        ;******************************
                        ;
                        ;	WRITE A RANDOM RECORD
                        ;	R8 -> FCB
                        ;	R3 -> LBA
                        ;
                        ;*****************************
                        ;
  D566   C120 D174      WRREC:	MOV	@DMAADDR,R4
                        ;	CLR R1
  D56A   2DA0 F020      	CALL	@MWRREC
  D56E   C041           	MOV	R1,R1	
  D570   1301           	JEQ	WRREC_X
  D572   0701           WRERR	SETO	R1
                        
  D574   C041           WRREC_X	MOV	R1,R1
  D576   2DC0           	RET
                        ;
                        ;*************************************************
                        ;*
                        ;*   TRACE THE FILES LINKED LIST AND FIND THE 
                        ;*   BAT ENTRY CORRESPONDING TO THE FILE'S NTH
                        ;*   BLOCK.
                        ;*   ENTER WITH FILES RELATIVE RECORD IN R2 (SET TO -1 IF LAST LINK REQUIRED)
                        ;*   EXIT  WITH DBN (DISK BLOCK NUMBER ) POINTER IN R7
                        ;*   AND WITH R1=R2 IF MATCH TO R1 AND R1=0FFF8 IF LAST LINK
                        ;*
                        ;*   CALL TRACES WITH FSB/CAB DURING WRSEQ TO SPEED UP TRACE
                        ;*
                        ;**************************************************
                        ;
  D578   C0E8 000C      TRACE:	MOV	@FSB(R8),R3		;GET FIRST FILE BLOCK - THIS IS THE START OF THE LINK
  D57C   04C1           	CLR	R1		;COUNTER
  D57E   2DA0 D5A4      TRACE1	CALL	@GETBATP		;GET THE BLOCK POINTER TO REQUESTED BAT ENTRY IN R7
  D582   C117           	MOV	*R7,R4		;GET NEXT ALLOCATION LINK
  D584   0284 FF80      	CI	R4,LASTBLK		;IS IT THE LAST BLOCK ?
  D588   1308           	JEQ	TRACE3		;YES
  D58A   8081           	C	R1,R2		;HAVE WE REACHED THE WANTED BLOCK YET ?
  D58C   1306           	JEQ	TRACE3		;YES
  D58E   0581           	INC	R1		;BUMP THE RECORD POINTER
  D590   C0C4           	MOV	R4,R3		;GET THE LINK AND KEEP GOING
  D592   1301           	JEQ	TRACE2		;CAN'T IMAGINE WHY ?
  D594   10F4           	JMP	TRACE1
  D596   0701           TRACE2	SETO	R1
  D598   2DC0           	RET
  D59A   C807 D16A      TRACE3	MOV	R7,@CBP		;CURRENT BLOCK POINTER
  D59E   C803 D168      	MOV	R3,@CAB		;AND CURRENT NUMBER
  D5A2   2DC0           	RET
                        ;
                        ; GETBATP (GET BAT POINTER) CHECK TO SEE IF THE BAT NUMBER (WHICH WILL
                        ; INDEX INTO THE BAT) PASSED
                        ; IN R3 LIES WITHIN THE RANGE OF THE CURRENT
                        ; BAT WHICH IS IN MEMORY. IF NOT IT WILL READ
                        ; THE APPRORIATE BAT INTO THE BUFFER
                        ; R7 WILL BE RETURNED AS A POINTER TO THE INDEXED ELEMENT
                        ; REGISTERS R0->R5 ARE PRESERVED
                        ;
  D5A4   2D05           GETBATP: 	PUSHREG	R5
  D5A6   C003           	MOV	R3,R0		;THIS IS THE CAB (CURRENTLY ALLOCATED BLOCK)
  D5A8   0980           	SRL	R0,BATSF		;DETERMINE CURRENT BAT PAGE OR SECTOR BASED ON 256 BLOCKS PER PAGE
  D5AA   8800 D16E      	C	R0,@CBSECT		;CURRENT BAT SECTOR IN MEMORY
  D5AE   1303           	JEQ	FBAT0		;IN MEMORY
  D5B0   C040           	MOV	R0,R1		;BAT SECTOR TO BE READ IN
  D5B2   2DA0 D5C6      	CALL	@RDBAT		;UPDATE MEMORY VERSION OF BAT
                        ;
                        ;	WE HAVE CROSSED TO ANOTHER BAT PAGE, NEED TO ADJUST
                        ;
  D5B6   2D45           FBAT0	POPREG	R5		;NEED TO POP HERE TO GET R3
  D5B8   C1C3           	MOV	R3,R7
  D5BA   0A17           	SLA	R7,1		;TWO BYTES PER ENTRY AND MAKES IT WORD EVEN
  D5BC   0247 00FF      	ANDI	R7,BATMSK		;MASK OFF HIGH BITS SO WE JUST HAVE THE BLOCK INDEX INTO THE 256 BAT ENTRY PAGE
  D5C0   0227 D64A      	AI	R7,BATBUFF		;R7->INDEXED ELEMENT
  D5C4   2DC0           	RET			;ALL IS OKAY
                        ;
                        ;	READ IN THE BAT
                        ;	R1 HOLDS CURRENT BAT SECTOR TO READ IN 
                        ;	DON'T CHECK IF ALREADY IN MEMORY AS THE CALLING ROUTINE WILL DO THAT
                        ;	R1=0 FOR 1ST 1 FOR 2ND ETC
                        ;
  D5C6   C020 D646      RDBAT:	MOV	@BATCHG,R0		;IF THERE HAS BEEN A CHANGE FIRST UPDATE
  D5CA   0580           	INC	R0
  D5CC   1607           	JNE	RDBAT1		;NO CHANGE SO PERFORM AS REQUESTED
                        ;
                        ;	WRITE MODIFIED BAT TO DISC
                        ;
  D5CE   8801 D16E      RDBAT0	C	R1,@CBSECT		;IF BAT SECTOR IN MEMORY EXIT
  D5D2   1314           	JEQ	RDBAT2
  D5D4   2E01           	PUSH	R1		;CHANGE SO DON'T READ IF IF NOT NECESSARY
  D5D6   2DA0 D5FE      	CALL	@WRBAT		;FORCE UPDATE OF DISK BAT
  D5DA   2E41           	POP	R1
  D5DC   C801 D16E      RDBAT1	MOV	R1,@CBSECT		;NEW SECTOR
  D5E0   0203 0002      	LI	R3,BAT_LBA
  D5E4   0A11           	SLA	R1,1		;2 LBAS PER SECTOR
  D5E6   A0C1           	A	R1,R3		;THIS IS THE BAT
  D5E8   C803 D178      	MOV	R3,@LBA+2		;JUST IN CASE
  D5EC   0204 D64A      	LI	R4,BATBUFF 		;USE THIS BUFFER
  D5F0   2DA0 F01C      	CALL	@MRDREC	 	;READ THE RECORD IN
  D5F4   C041           	MOV	R1,R1	 	;ERROR ?
  D5F6   1302           	JEQ	RDBAT2	 	;NO
  D5F8   0701           	SETO	R1	 	;SHOW ERROR
  D5FA   C041           	MOV	R1,R1
  D5FC   2DC0           RDBAT2	RET
                        ;
                        ;	WRITE OUT A BAT SECTOR
                        ;	CBSECT HOLDS BAT SECTOR TO BE WRITTEN TO DISK
                        ;
  D5FE   C0A0 D16E      WRBAT:	MOV	@CBSECT,R2 		;BAT SECTOR; 1 TO 3
  D602   0203 0002      	LI	R3,BAT_LBA
  D606   0A12           	SLA	R2,1		;2 LBAS PER SECTOR
  D608   A0C2           	A	R2,R3
  D60A   C803 D178      	MOV	R3,@LBA+2		;JUST IN CASE
  D60E   0204 D64A      	LI	R4,BATBUFF		;USE SAME BUFFER
  D612   2DA0 F020      	CALL	@MWRREC
  D616   C041           	MOV	R1,R1
  D618   1301           	JEQ	WRB_X
  D61A   0701           	SETO	R1
  D61C   C041           WRB_X	MOV	R1,R1
  D61E   04E0 D646      	CLR	@BATCHG		;DISK BM NOW EQUALS MEMORY VERSION
  D622   2DC0           	RET
                        
                        ;
                        ;
                        ;  WRITE OUT THE DIRECTORY TO THE DISC.
                        ;  R8 HOLDS THE FCB
                        ;
                        ;DB_WRDIR:	TEXT	"WRDIR"	;TEMP FOR DEBUG
                        ;	WORD	0
                        ;	EVEN
  D624   C0E0 D17A      WRDIR:	MOV	@CDSECT,R3		;R3 HOLDS RECORD OFFSET WITHIN BLOCK
  D628   0A13           	SLA	R3,1		;TWO LBAS PER SECTOR
  D62A   0200 0008      	LI	R0,DIR_LBA		;FIRST DIRECTORY ENTRY LBA VALUE
  D62E   A0C0           	A	R0,R3
  D630   C803 D178      	MOV	R3,@LBA+2		;SET THE LBA - NOT SURE THIS IS NECESSARY
  D634   0204 D84A      	LI	R4,DIRBUFF
                        ;
                        ; CALL TO MWRREC
                        ; R3 HOLDS THE LSB OF THE LBA VALUE FOR THE SECTOR WE WANT TO READ OR WRITE
                        ; R4 HOLDS THE BUFFER ADDRESS
                        ;
  D638   2DA0 F020      	CALL	@MWRREC
  D63C   C041           	MOV	R1,R1
  D63E   1301           	JEQ	WRD_X
  D640   0701           	SETO	R1
                        
  D642   C041           WRD_X	MOV	R1,R1
  D644   2DC0           	RET
                        
                        ;
                        ;======================================================
                        ;	MAP THE TRACK NUMBER IN R2 TO
                        ;	EITHER SIDE 0 OR SIDE 1
                        ;
                        ;	RETURN IN R2 AND @TRACK
                        ;========================================================
                        ;
                        ;SETTRK:	CI	R2,TRKDSK		;CHECK FOR SIDE 2
                        ;	JLT	SETTRK1
                        ;	AI	R2,-2*TRKDSK
                        ;	INC	R2
                        ;	NEG	R2
                        ;	ORI	R2,8000H		;SET MSB TO INDICATE SIDE 1
                        ;SETTRK1:
                        ;	MOV	R2,@TRACK
                        ;	RET
                        ;
                        ;
                        ;	BUFFERS ETC
                        ;
                        ;	THE FLAG BATCHG(BIT MAP CHANGE) IS SET WHENEVER AN ALLOCATION
                        ;	BIT IN THE BLOCK ALLOCATION TABLE (BAT)HAS BEEN 
                        ;	CLEARED/ALLOCATED. THIS ENSURES THAT THE BAT
                        ;	WILL NOT BE OVERWRITTEN BY THE DISK VERSION OF THE BIT MAP.
                        ;	THIS FLAG IS CLEARED ONCE A BIT MAP DISK WRITE IS FORCED BY
                        ;	A FILE CLOSURE OR A DIRECTORY FSB BEING REQUESTED.
                        ;
  D646   0000           BATCHG:	WORD	0		;BAT CHANGE FLAG
  D648   0000           MCNT:	WORD	0		;BYTES LEFT IN BUFFER
  D64A                  BATBUFF:	BSS	BUFSIZ		;BAT BUFFER
  D84A                  DIRBUFF:	BSS	BUFSIZ		;DIRECTORY BUFFER
                        INTBUFF:
  DA4A                  MLBUF:	BSS	BUFSIZ		;BUFFER FOR C COMPILED PROGRAMMES
                        
                        ;
  DC4A                  	END

No error(s).
GETSIZ           D38C  SECBLK           0004  LRBL             0014  DIRBLK           D4EE  
EXIT             D160  FUN01            D110  ALLONES          D165  FUN11            D124  
PUSH             2E00  FUN21            D138  BLK2_LBA         0012  FUN31            D14C  
GETSIZ1          D39C  FINAL_LBA        0010  NAM              0000  DLOOK            D3AC  
CMLTI            0020  WRCMD            0002  WRBAT            D5FE  NAMEOFF2         0012  
RENAM2           D46A  BATCHG           D646  WRRND            D346  DLOOK1           D3B2  
RENAME           D44A  DLOOK4           D3BE  ERAERR           D4C8  DLOOK5           D3D0  
RDERR            D560  DLOOK6           D3D4  CBP              D16A  FSB              000C  
FBAT0            D5B6  TRACE            D578  BATMSK           00FF  GETBATP          D5A4  
FUN08            D11E  MMLTA            D24E  FUN28            D146  WRD_X            D642  
FCLOSE           D26C  LASTBLK          FF80  FUN04            D116  TRACE1           D57E  
FUN24            D13E  TRACE2           D596  POPREG           2D40  BDOS0            D17E  
R1               0001  TRACE3           D59A  R3               0003  MWBOOT           F028  
R2               0002  DMAFUN           D1B6  R7               0007  MONITOR          F000  
R8               0008  DB_FCLOSE        D264  RDSEQ            D2FA  MRDREC           F01C  
FUN00            D10E  RDREC            D554  FUN20            D136  MAKEMLT          D240  
FUN40            D15E  MON_PTR          0086  FDIRRN           0004  RDREC1           D562  
POP              2E40  RWREC            D354  FLA              0010  CBN              0018  
NXTLTR           D3C4  MEMBASE          80C0  WRREC_X          D574  CIN              D194  
CDSECT           D17A  NXTBLK2          D538  MRDID            F024  CRN              001A  
MINUS1           FFFF  RWREC_R          D370  WHEX             2E80  FUN06            D11A  
ERA02            D4C0  FUN16            D12E  RECLAIM          D48C  FUN26            D142  
BAT_LBA          0002  FUN36            D156  DIR_LBA          0008  GETMLT           D218  
FUN09            D120  RET              2DC0  FUN29            D148  LBA              D176  
INTBUFF          DA4A  BDOS             D100  WRSEQ            D296  BATBUFF          D64A  
FUN15            D12C  FUN02            D112  FUN35            D154  FUN12            D126  
WRSEQ1           D2F6  FUN22            D13A  WRSEQ0           D2D6  FUN32            D14E  
DIROPN           D4CC  DIRBUFF          D84A  DMAADDR          D174  MKFIL1           D430  
WILD             D164  MKFIL2           D414  FTY              000B  DIRB01           D51C  
WRADDR           D172  DIRB02           D51E  WRB_X            D61C  DIRB03           D522  
WRDIR            D624  DIRSIZ           0020  LBASECT          0001  CAB              D168  
ERA01            D4B2  OPENENT          D1FC  NXTBLK4          D54C  RELB             001C  
FUN18            D132  BYTSEC           0200  MCONIN           F008  RELR             001E  
FUN34            D152  WRREC            D566  CALL             2D80  _SETDMA          D1C0  
R6               0006  CDFUNC           D1B0  MAKFIL           D3E0  RSVDSEC          0001  
FUN10            D122  CLOSEB           D294  MSEEK            F018  RECTBC           D52A  
FSZ              000E  MPAGE            0022  OPENE            D214  RDBAT            D5C6  
WRERR            D572  RDRND            D330  MLBUF            DA4A  RDBAT0           D5CE  
PUSHREG          2D00  SETREL           D39E  MAKERR           D446  RDBAT2           D5FC  
FUN19            D134  RDBAT1           D5DC  DEBUG            2FC0  ERA00            D4AE  
FUN25            D140  MRECAL           F014  WRSEQ2           D2F8  CRNTBC           D526  
CCMD             D17C  CBO              D16C  BOOT_LBA         0000  NXTBLK3          D550  
NSIDES           0002  RECTBC1          D532  MCONOUT          F00C  SEARCH1          D374  
DISK             D166  FUN07            D11C  FUN38            D15A  FUN17            D130  
R0               0000  FUN27            D144  R5               0005  FUN37            D158  
FUN30            D14A  MSELDSK          F010  RDCMD            0001  NTHR             D3FE  
OPENA            D1F6  SECTRK           0012  NONTRY           D3DC  DIRTRK           0000  
FUN39            D15C  BATTRK           0000  NBATS            0001  FOPEN            D1DC  
BATSF            0008  ERAFIL           D46C  RENAM1           D460  FBATSEC          0002  
SEARCH2          D384  MLOAD            D1C6  R4               0004  NDSECT           0004  
FCLOSE1          D286  FUN03            D114  NXTBLK           D534  FUN13            D128  
FUN05            D118  FUN23            D13C  DCONIO           D19C  FUN33            D150  
FUN14            D12A  DIRENT           D170  CBSECT           D16E  NMSECT           0021  
RDSEQ1           D32C  COUT             D18A  MCNT             D648  DSKFUN           D1A6  
MWRREC           F020  NAMSIZ           000B  BUFSIZ           0200  
